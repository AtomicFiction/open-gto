# This file was automatically generated by SWIG (http://www.swig.org).
# Version 1.3.31
#
# Don't modify this file, modify the SWIG interface instead.
# This file is compatible with both classic and new-style classes.

"""
This module defines a generic GtoDB class.  This class can be used to
work with GTO data at an extremely high level, without the need to derive a new
reader class or change your workflow to accomodate the somewhat restrictive GTO
I/O routines.

The gtoDB module is intended to replace the older gtoContainer module.  It's a
lot faster, since it doesn't convert data into Python objects until needed.
It also doesn't try to be quite as fancy, so accessing objects, components,
and properties as if they were attributes is no longer supported.

Perhaps the best introduction to what gtoDB can do is
with a few examples.  Here's a simple one that prints the names of every
object, component, and property in a file:

    from gtoDB import *

    for object in GtoDB('foo.gto'):
        for component in object:
            for property in component:
                print object, component, property

Let's say that you want to check every object for the existence of a particular
component/property and print the stored data if it's there:

    for obj in GtoDB( 'foo.gto' ):
        if 'channels' in obj and 'diff' in obj['channels']:
            print obj['channels']['diff']()


Let's say we want to start fresh and make a really simple gto file:

    #!/usr/bin/env python
    
    from gtoDB import *

    gtoFile = GtoDB()

    obj = Object('myobject', 'objprotocol', 1)
    gtoFile.append(obj)

    comp = Component('mycomponent')
    obj.append(comp)
    
    comp.append(Property('intProp', range(1,11)))
    comp.append(Property('strProp', 'hello'))
    comp.append(Property('floatProp', (1.1, 2.2)))

    gtoFile.write('test.gto')


One very important note:  GtoDB maintains a separate C++ database of data in
memory (using Gto::RawData).  Objects, Components, and most importantly
Properties (and their data) are converted into Python objects on-demand. 
Also, each of these containers delete their contents when destroyed. 
Therefore, don't hang on to a Property instance, for example, after the GtoDB
object has gone out of scope.  The data-access methods on the Property object
will return a copy of the data that *is* safe to hang on to after the Property
itself is gone.


"""

import _gtoDB
import new
new_instancemethod = new.instancemethod
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'PySwigObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static) or hasattr(self,name):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError,name

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

import types
try:
    _object = types.ObjectType
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0
del types


class PySwigIterator(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PySwigIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PySwigIterator, name)
    def __init__(self): raise AttributeError, "No constructor defined"
    __repr__ = _swig_repr
    __swig_destroy__ = _gtoDB.delete_PySwigIterator
    __del__ = lambda self : None;
    def value(*args): return _gtoDB.PySwigIterator_value(*args)
    def incr(*args): return _gtoDB.PySwigIterator_incr(*args)
    def decr(*args): return _gtoDB.PySwigIterator_decr(*args)
    def distance(*args): return _gtoDB.PySwigIterator_distance(*args)
    def equal(*args): return _gtoDB.PySwigIterator_equal(*args)
    def copy(*args): return _gtoDB.PySwigIterator_copy(*args)
    def next(*args): return _gtoDB.PySwigIterator_next(*args)
    def previous(*args): return _gtoDB.PySwigIterator_previous(*args)
    def advance(*args): return _gtoDB.PySwigIterator_advance(*args)
    def __eq__(*args): return _gtoDB.PySwigIterator___eq__(*args)
    def __ne__(*args): return _gtoDB.PySwigIterator___ne__(*args)
    def __iadd__(*args): return _gtoDB.PySwigIterator___iadd__(*args)
    def __isub__(*args): return _gtoDB.PySwigIterator___isub__(*args)
    def __add__(*args): return _gtoDB.PySwigIterator___add__(*args)
    def __sub__(*args): return _gtoDB.PySwigIterator___sub__(*args)
    def __iter__(self): return self
PySwigIterator_swigregister = _gtoDB.PySwigIterator_swigregister
PySwigIterator_swigregister(PySwigIterator)

GTO_MAGIC = _gtoDB.GTO_MAGIC
GTO_MAGICl = _gtoDB.GTO_MAGICl
GTO_MAGIC_TEXT = _gtoDB.GTO_MAGIC_TEXT
GTO_MAGIC_TEXTl = _gtoDB.GTO_MAGIC_TEXTl
GTO_VERSION = _gtoDB.GTO_VERSION
Transposed = _gtoDB.Transposed
Matrix = _gtoDB.Matrix
Int = _gtoDB.Int
Float = _gtoDB.Float
Double = _gtoDB.Double
Half = _gtoDB.Half
String = _gtoDB.String
Boolean = _gtoDB.Boolean
Short = _gtoDB.Short
Byte = _gtoDB.Byte
NumberOfDataTypes = _gtoDB.NumberOfDataTypes
ErrorType = _gtoDB.ErrorType
class Strings(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Strings, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Strings, name)
    __repr__ = _swig_repr
    def iterator(*args): return _gtoDB.Strings_iterator(*args)
    def __iter__(self): return self.iterator()
    def __nonzero__(*args): return _gtoDB.Strings___nonzero__(*args)
    def __len__(*args): return _gtoDB.Strings___len__(*args)
    def pop(*args): return _gtoDB.Strings_pop(*args)
    def __getslice__(*args): return _gtoDB.Strings___getslice__(*args)
    def __setslice__(*args): return _gtoDB.Strings___setslice__(*args)
    def __delslice__(*args): return _gtoDB.Strings___delslice__(*args)
    def __delitem__(*args): return _gtoDB.Strings___delitem__(*args)
    def __getitem__(*args): return _gtoDB.Strings___getitem__(*args)
    def __setitem__(*args): return _gtoDB.Strings___setitem__(*args)
    def append(*args): return _gtoDB.Strings_append(*args)
    def empty(*args): return _gtoDB.Strings_empty(*args)
    def size(*args): return _gtoDB.Strings_size(*args)
    def clear(*args): return _gtoDB.Strings_clear(*args)
    def swap(*args): return _gtoDB.Strings_swap(*args)
    def get_allocator(*args): return _gtoDB.Strings_get_allocator(*args)
    def begin(*args): return _gtoDB.Strings_begin(*args)
    def end(*args): return _gtoDB.Strings_end(*args)
    def rbegin(*args): return _gtoDB.Strings_rbegin(*args)
    def rend(*args): return _gtoDB.Strings_rend(*args)
    def pop_back(*args): return _gtoDB.Strings_pop_back(*args)
    def erase(*args): return _gtoDB.Strings_erase(*args)
    def __init__(self, *args): 
        this = _gtoDB.new_Strings(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(*args): return _gtoDB.Strings_push_back(*args)
    def front(*args): return _gtoDB.Strings_front(*args)
    def back(*args): return _gtoDB.Strings_back(*args)
    def assign(*args): return _gtoDB.Strings_assign(*args)
    def resize(*args): return _gtoDB.Strings_resize(*args)
    def insert(*args): return _gtoDB.Strings_insert(*args)
    def reserve(*args): return _gtoDB.Strings_reserve(*args)
    def capacity(*args): return _gtoDB.Strings_capacity(*args)
    __swig_destroy__ = _gtoDB.delete_Strings
    __del__ = lambda self : None;
Strings_swigregister = _gtoDB.Strings_swigregister
Strings_swigregister(Strings)

class Property(_object):
    """
    Represents a single GTO Property and the data it contains.  Property
    data can be accessed like so:

        property()       # Returns data in its native form (int, float, str, tuple)
        property[i]      # Returns a single item of the property's data
        property[i:j]    # Returns a slice of the property's data

    Information about the Property itself can be had via the attributes name, interp,
    size, width, and type.).  A Property's name and interp string can be changed, 
    but the size, width, and data type cannot.  Property data can be changed:
            
        property[0] = 'hello'
        property[0:2] = (0.1, 0.2)


    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Property, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Property, name)
    __swig_setmethods__["name"] = _gtoDB.Property_name_set
    __swig_getmethods__["name"] = _gtoDB.Property_name_get
    if _newclass:name = _swig_property(_gtoDB.Property_name_get, _gtoDB.Property_name_set)
    __swig_setmethods__["interp"] = _gtoDB.Property_interp_set
    __swig_getmethods__["interp"] = _gtoDB.Property_interp_get
    if _newclass:interp = _swig_property(_gtoDB.Property_interp_get, _gtoDB.Property_interp_set)
    __swig_getmethods__["size"] = _gtoDB.Property_size_get
    if _newclass:size = _swig_property(_gtoDB.Property_size_get)
    __swig_getmethods__["width"] = _gtoDB.Property_width_get
    if _newclass:width = _swig_property(_gtoDB.Property_width_get)
    __swig_getmethods__["type"] = _gtoDB.Property_type_get
    if _newclass:type = _swig_property(_gtoDB.Property_type_get)
    def __init__(self, *args): 
        """
        __init__(self, string name, string interp, DataType type, size_t size, 
            size_t width=1) -> Property
        __init__(self, string name, string interp, DataType type, size_t size) -> Property
        __init__(self, string name, DataType type, size_t size, size_t width=1) -> Property
        __init__(self, string name, DataType type, size_t size) -> Property
        __init__(self, string name, string interp, PyObject data) -> Property
        __init__(self, string name, PyObject data) -> Property

        Variants of the contstructor that accept a PyObject parameter will auto-
        detect the data type, size, and width parameters for the new Property based
        on the type and structure of the Python object, and set the property data
        accordingly.  For example:

            Property('a', 'hello')          => type=string, size=1, width=1
            Property('b', ('hello', 'bye')  => type=string, size=2, width=1
            Property('c', 3.14159)          => type=float, size=1, width=1
            Property('d', (1, 2))           => type=int, size=2, width=1
            Property('e', ((1, 2), (3, 4))) => type=int, size=2, width=2
            Property('f', range(10))        => type=int, size=10, width=1

        """
        this = _gtoDB.new_Property(*args)
        try: self.this.append(this)
        except: self.this = this
    def __repr__(*args):
        """__repr__(self) -> char"""
        return _gtoDB.Property___repr__(*args)

    def __cmp__(*args):
        """__cmp__(self, other) -> long"""
        return _gtoDB.Property___cmp__(*args)

    def __len__(*args):
        """Equivalent to property.size"""
        return _gtoDB.Property___len__(*args)

    def __call__(*args):
        """Returns all property data in its native form (int, float, str, tuple)"""
        return _gtoDB.Property___call__(*args)

    def __getitem__(*args):
        """__getitem__(self, key) -> PyObject"""
        return _gtoDB.Property___getitem__(*args)

    def __setitem__(*args):
        """__setitem__(self, key, value)"""
        return _gtoDB.Property___setitem__(*args)

    def __contains__(*args):
        """__contains__(self, item) -> bool"""
        return _gtoDB.Property___contains__(*args)

    __swig_destroy__ = _gtoDB.delete_Property
    __del__ = lambda self : None;
Property_swigregister = _gtoDB.Property_swigregister
Property_swigregister(Property)

class Component(_object):
    """
    Represents a single GTO Component which may contain any number of 
    properties.  Information about the object itself is had via
    the attributes name, interp, and flags.

    This class can operate as either a dictionary or a list:

       property   = component[0]
       property   = component['position'] 
       properties = component[0:2]
       numProperties = len(component)

       if 'position' in component:   
           del component['position']

    Most standard list/dictionary methods are supported.

    If a Component is deleted, it will delete all the Properties it contains.
    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Component, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Component, name)
    __swig_setmethods__["name"] = _gtoDB.Component_name_set
    __swig_getmethods__["name"] = _gtoDB.Component_name_get
    if _newclass:name = _swig_property(_gtoDB.Component_name_get, _gtoDB.Component_name_set)
    __swig_setmethods__["interp"] = _gtoDB.Component_interp_set
    __swig_getmethods__["interp"] = _gtoDB.Component_interp_get
    if _newclass:interp = _swig_property(_gtoDB.Component_interp_get, _gtoDB.Component_interp_set)
    __swig_setmethods__["flags"] = _gtoDB.Component_flags_set
    __swig_getmethods__["flags"] = _gtoDB.Component_flags_get
    if _newclass:flags = _swig_property(_gtoDB.Component_flags_get, _gtoDB.Component_flags_set)
    def __init__(self, *args): 
        """
        __init__(self, string name, string interp, int flags) -> Component
        __init__(self, string name, int flags) -> Component
        __init__(self, string name, string interp) -> Component
        __init__(self, string name) -> Component
        """
        this = _gtoDB.new_Component(*args)
        try: self.this.append(this)
        except: self.this = this
    def __repr__(*args):
        """__repr__(self) -> char"""
        return _gtoDB.Component___repr__(*args)

    def __len__(*args):
        """Returns the number of Properties in this component"""
        return _gtoDB.Component___len__(*args)

    def __cmp__(*args):
        """Compares component names *only*"""
        return _gtoDB.Component___cmp__(*args)

    def __getitem__(*args):
        """__getitem__(self, key) -> PyObject"""
        return _gtoDB.Component___getitem__(*args)

    def __setitem__(*args):
        """__setitem__(self, key, value)"""
        return _gtoDB.Component___setitem__(*args)

    def __delitem__(*args):
        """__delitem__(self, key)"""
        return _gtoDB.Component___delitem__(*args)

    def __contains__(*args):
        """__contains__(self, item) -> bool"""
        return _gtoDB.Component___contains__(*args)

    def keys(*args):
        """keys(self) -> PyObject"""
        return _gtoDB.Component_keys(*args)

    def values(*args):
        """values(self) -> Properties"""
        return _gtoDB.Component_values(*args)

    def items(*args):
        """items(self) -> PyObject"""
        return _gtoDB.Component_items(*args)

    def append(*args):
        """append(self, item)"""
        return _gtoDB.Component_append(*args)

    def extend(*args):
        """extend(self, sequence)"""
        return _gtoDB.Component_extend(*args)

    __swig_destroy__ = _gtoDB.delete_Component
    __del__ = lambda self : None;
Component_swigregister = _gtoDB.Component_swigregister
Component_swigregister(Component)

class Object(_object):
    """
    Represents a single GTO Object which may contain any number of 
    components.  Information about the object itself is had via
    the attributes name, protocol, and protocolVersion.

    This class can operate as either a dictionary or a list:

       component  = object[0]
       component  = object['points'] 
       components = object[0:2]
       numComponents = len(object)

       if 'points' in object:   
           del object['points']

    Most standard list/dictionary methods are supported.

    If an Object is deleted, it will delete all the Components it contains.
    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Object, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Object, name)
    def __init__(self, *args): 
        """__init__(self, string name, string protocol, unsigned int protocolVersion) -> Object"""
        this = _gtoDB.new_Object(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _gtoDB.delete_Object
    __del__ = lambda self : None;
    __swig_setmethods__["name"] = _gtoDB.Object_name_set
    __swig_getmethods__["name"] = _gtoDB.Object_name_get
    if _newclass:name = _swig_property(_gtoDB.Object_name_get, _gtoDB.Object_name_set)
    __swig_setmethods__["protocol"] = _gtoDB.Object_protocol_set
    __swig_getmethods__["protocol"] = _gtoDB.Object_protocol_get
    if _newclass:protocol = _swig_property(_gtoDB.Object_protocol_get, _gtoDB.Object_protocol_set)
    __swig_setmethods__["protocolVersion"] = _gtoDB.Object_protocolVersion_set
    __swig_getmethods__["protocolVersion"] = _gtoDB.Object_protocolVersion_get
    if _newclass:protocolVersion = _swig_property(_gtoDB.Object_protocolVersion_get, _gtoDB.Object_protocolVersion_set)
    def __repr__(*args):
        """__repr__(self) -> char"""
        return _gtoDB.Object___repr__(*args)

    def __len__(*args):
        """Returns the number of Components in this object"""
        return _gtoDB.Object___len__(*args)

    def __cmp__(*args):
        """Compares object names *only*"""
        return _gtoDB.Object___cmp__(*args)

    def __getitem__(*args):
        """__getitem__(self, key) -> PyObject"""
        return _gtoDB.Object___getitem__(*args)

    def __setitem__(*args):
        """__setitem__(self, key, value)"""
        return _gtoDB.Object___setitem__(*args)

    def __delitem__(*args):
        """__delitem__(self, key)"""
        return _gtoDB.Object___delitem__(*args)

    def __contains__(*args):
        """__contains__(self, item) -> bool"""
        return _gtoDB.Object___contains__(*args)

    def keys(*args):
        """keys(self) -> PyObject"""
        return _gtoDB.Object_keys(*args)

    def values(*args):
        """values(self) -> Components"""
        return _gtoDB.Object_values(*args)

    def append(*args):
        """append(self, item)"""
        return _gtoDB.Object_append(*args)

    def extend(*args):
        """extend(self, sequence)"""
        return _gtoDB.Object_extend(*args)

Object_swigregister = _gtoDB.Object_swigregister
Object_swigregister(Object)

class GtoDB(_object):
    """
    Represents a single GTO file which may contain any number of objects.

    This class can operate as either a dictionary or a list:
        
        object  = gtoDB[0]
        objects = gtoDB[0:3]
        object  = gtoDB['pSphere1']

        gtoDB[0] = object
        gtoDB[0:3] = objects

       if 'pSphere1' in gtoDB:   
           del gtoDB['pSphere1']

    Most standard list/dictionary methods are supported.

    If a GtoDB is deleted, it will delete all the Objects it contains.

    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, GtoDB, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, GtoDB, name)
    __repr__ = _swig_repr
    BinaryGTO = _gtoDB.GtoDB_BinaryGTO
    CompressedGTO = _gtoDB.GtoDB_CompressedGTO
    TextGTO = _gtoDB.GtoDB_TextGTO
    def __init__(self, *args): 
        """
        __init__(self) -> GtoDB
        __init__(self, string filename) -> GtoDB
        """
        this = _gtoDB.new_GtoDB(*args)
        try: self.this.append(this)
        except: self.this = this
    def read(*args):
        """
        read(self, string filename)

        If called multiple times, this function will merge data
        into the existing database.  This is equivalent to the command-
        line 'gtomerge' tool.

        """
        return _gtoDB.GtoDB_read(*args)

    def write(*args):
        """
        write(self, string filename, FileType mode=CompressedGTO)
        write(self, string filename)
        """
        return _gtoDB.GtoDB_write(*args)

    def __len__(*args):
        """Returns the number of Objects in this database"""
        return _gtoDB.GtoDB___len__(*args)

    def __getitem__(*args):
        """__getitem__(self, key) -> PyObject"""
        return _gtoDB.GtoDB___getitem__(*args)

    def __setitem__(*args):
        """__setitem__(self, key, value)"""
        return _gtoDB.GtoDB___setitem__(*args)

    def __delitem__(*args):
        """__delitem__(self, key)"""
        return _gtoDB.GtoDB___delitem__(*args)

    def __contains__(*args):
        """__contains__(self, item) -> bool"""
        return _gtoDB.GtoDB___contains__(*args)

    def keys(*args):
        """keys(self) -> PyObject"""
        return _gtoDB.GtoDB_keys(*args)

    def values(*args):
        """values(self) -> Objects"""
        return _gtoDB.GtoDB_values(*args)

    def items(*args):
        """items(self) -> PyObject"""
        return _gtoDB.GtoDB_items(*args)

    def append(*args):
        """append(self, item)"""
        return _gtoDB.GtoDB_append(*args)

    def extend(*args):
        """extend(self, sequence)"""
        return _gtoDB.GtoDB_extend(*args)

    def clear(*args):
        """clear(self)"""
        return _gtoDB.GtoDB_clear(*args)

    __swig_destroy__ = _gtoDB.delete_GtoDB
    __del__ = lambda self : None;
GtoDB_swigregister = _gtoDB.GtoDB_swigregister
GtoDB_swigregister(GtoDB)



