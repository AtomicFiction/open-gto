\input texinfo   @c -*-texinfo-*-
@c %**start of header
@setfilename gto.info
@settitle GTO File Format, Protocols, and Utilities
@setchapternewpage off
@c %**end of header

@ifinfo
This file documents version 2.1 of the "GTO" File Format, Protocols, and
Utilities.

Permission is granted to make and distribute verbatim copies of
this manual provided the copyright notice and this permission notice
are preserved on all copies.

@ignore
Permission is granted to process this file through TeX and print the
results, provided the printed document carries copying permission
notice identical to this one except for the removal of this paragraph
(this paragraph not being relevant to the printed manual).
@end ignore

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided that the entire
resulting derived work is distributed under the terms of a permission
notice identical to this one.
@end ifinfo
     
@c  This title page illustrates only one of the
@c  two methods of forming a title page.
     
@titlepage
@title GTO: The Kitchen Sink of Geometry
@subtitle File Format, Protocols, and Utilities.
@author Jim Hourihan, Tweak Films
     
@c  The following two commands
@c  start the copyright page.
@page
@vskip 0pt plus 1filll
Copyright @copyright{} 2002-2004 Tweak Films. All rights reserved.
Permission is granted to make and distribute verbatim copies of
this manual provided the copyright notice and this permission notice
are preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided that the entire
resulting derived work is distributed under the terms of a permission
notice identical to this one.
     
@end titlepage

@contents

@c -------------------------------------
@ifnottex
@node Top, Copying, (dir), (dir)
@top GTO File Format
     
This document describes the GTO file format, protocols, and
utilities. 

Copyright @copyright{} 2002-2004 Tweak Films. All rights reserved.
Permission is granted to make and distribute verbatim copies of
this manual provided the copyright notice and this permission notice
are preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided that the entire
resulting derived work is distributed under the terms of a permission
notice identical to this one.

This document applies to version 2.1 of the file format.
@end ifnottex

@menu
* Copying::              GTO licensing terms.
* Installation::         Compiling and Installing.
* Overview::             Uses for the GTO format.
* Format::               File format on disk.
* Types::                Types of property data that can be stored.
* Protocols::            How to interpret the data.
* Names::                Naming Convensions.
* Issues::               Problems and questionable aspects of the format.
* Extending::            Extending protocols or the file format.
* Library::              Reading and Writing using the C++ library.
* Module::               Reading and Writing using the Python module.
* Utilities::            Utility Programs and Plug-ins.
* Changes::              Changes between versions.
* Reference::            Index of functions, types, and variables.
@end menu

@c ----------------------------------------------------------------------
@c ----------------------------------------------------------------------
     
@node Copying, Installation, Top, Top
@unnumbered GNU LESSER GENERAL PUBLIC LICENSE
@center Version 2.1, February 1999

@display
Copyright @copyright{} 1991, 1999 Free Software Foundation, Inc.  59
Temple Place, Suite 330, Boston, MA 02111-1307 USA

Everyone is permitted to copy and distribute verbatim copies of this
license document, but changing it is not allowed.

[This is the first released version of the Lesser GPL.  It also counts
as the successor of the GNU Library Public License, version 2, hence
the version number 2.1.]

@end display

@heading Preamble

  The licenses for most software are designed to take away your
freedom to share and change it.  By contrast, the GNU General Public
Licenses are intended to guarantee your freedom to share and change
free software--to make sure the software is free for all its users.

  This license, the Lesser General Public License, applies to some
specially designated software packages--typically libraries--of the
Free Software Foundation and other authors who decide to use it.  You
can use it too, but we suggest you first think carefully about whether
this license or the ordinary General Public License is the better
strategy to use in any particular case, based on the explanations below.

  When we speak of free software, we are referring to freedom of use,
not price.  Our General Public Licenses are designed to make sure that
you have the freedom to distribute copies of free software (and charge
for this service if you wish); that you receive source code or can get
it if you want it; that you can change the software and use pieces of
it in new free programs; and that you are informed that you can do
these things.

  To protect your rights, we need to make restrictions that forbid
distributors to deny you these rights or to ask you to surrender these
rights.  These restrictions translate to certain responsibilities for
you if you distribute copies of the library or if you modify it.

  For example, if you distribute copies of the library, whether gratis
or for a fee, you must give the recipients all the rights that we gave
you.  You must make sure that they, too, receive or can get the source
code.  If you link other code with the library, you must provide
complete object files to the recipients, so that they can relink them
with the library after making changes to the library and recompiling
it.  And you must show them these terms so they know their rights.

  We protect your rights with a two-step method: (1) we copyright the
library, and (2) we offer you this license, which gives you legal
permission to copy, distribute and/or modify the library.

  To protect each distributor, we want to make it very clear that
there is no warranty for the free library.  Also, if the library is
modified by someone else and passed on, the recipients should know
that what they have is not the original version, so that the original
author's reputation will not be affected by problems that might be
introduced by others.

  Finally, software patents pose a constant threat to the existence of
any free program.  We wish to make sure that a company cannot
effectively restrict the users of a free program by obtaining a
restrictive license from a patent holder.  Therefore, we insist that
any patent license obtained for a version of the library must be
consistent with the full freedom of use specified in this license.

  Most GNU software, including some libraries, is covered by the
ordinary GNU General Public License.  This license, the GNU Lesser
General Public License, applies to certain designated libraries, and
is quite different from the ordinary General Public License.  We use
this license for certain libraries in order to permit linking those
libraries into non-free programs.

  When a program is linked with a library, whether statically or using
a shared library, the combination of the two is legally speaking a
combined work, a derivative of the original library.  The ordinary
General Public License therefore permits such linking only if the
entire combination fits its criteria of freedom.  The Lesser General
Public License permits more lax criteria for linking other code with
the library.

  We call this license the "Lesser" General Public License because it
does Less to protect the user's freedom than the ordinary General
Public License.  It also provides other free software developers Less
of an advantage over competing non-free programs.  These disadvantages
are the reason we use the ordinary General Public License for many
libraries.  However, the Lesser license provides advantages in certain
special circumstances.

  For example, on rare occasions, there may be a special need to
encourage the widest possible use of a certain library, so that it becomes
a de-facto standard.  To achieve this, non-free programs must be
allowed to use the library.  A more frequent case is that a free
library does the same job as widely used non-free libraries.  In this
case, there is little to gain by limiting the free library to free
software only, so we use the Lesser General Public License.

  In other cases, permission to use a particular library in non-free
programs enables a greater number of people to use a large body of
free software.  For example, permission to use the GNU C Library in
non-free programs enables many more people to use the whole GNU
operating system, as well as its variant, the GNU/Linux operating
system.

  Although the Lesser General Public License is Less protective of the
users' freedom, it does ensure that the user of a program that is
linked with the Library has the freedom and the wherewithal to run
that program using a modified version of the Library.

  The precise terms and conditions for copying, distribution and
modification follow.  Pay close attention to the difference between a
"work based on the library" and a "work that uses the library".  The
former contains code derived from the library, whereas the latter must
be combined with the library in order to run.

@center GNU LESSER GENERAL PUBLIC LICENSE
@center TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION

 

@enumerate 0
@item This License Agreement applies to any software library or other
program which contains a notice placed by the copyright holder or
other authorized party saying it may be distributed under the terms of
this Lesser General Public License (also called "this License").
Each licensee is addressed as "you".

  A "library" means a collection of software functions and/or data
prepared so as to be conveniently linked with application programs
(which use some of those functions and data) to form executables.

  The "Library", below, refers to any such software library or work
which has been distributed under these terms.  A "work based on the
Library" means either the Library or any derivative work under
copyright law: that is to say, a work containing the Library or a
portion of it, either verbatim or with modifications and/or translated
straightforwardly into another language.  (Hereinafter, translation is
included without limitation in the term "modification".)

  "Source code" for a work means the preferred form of the work for
making modifications to it.  For a library, complete source code means
all the source code for all modules it contains, plus any associated
interface definition files, plus the scripts used to control compilation
and installation of the library.

  Activities other than copying, distribution and modification are not
covered by this License; they are outside its scope.  The act of
running a program using the Library is not restricted, and output from
such a program is covered only if its contents constitute a work based
on the Library (independent of the use of the Library in a tool for
writing it).  Whether that is true depends on what the Library does
and what the program that uses the Library does.

@item You may copy and distribute verbatim copies of the Library's
complete source code as you receive it, in any medium, provided that
you conspicuously and appropriately publish on each copy an
appropriate copyright notice and disclaimer of warranty; keep intact
all the notices that refer to this License and to the absence of any
warranty; and distribute a copy of this License along with the
Library.

  You may charge a fee for the physical act of transferring a copy,
and you may at your option offer warranty protection in exchange for a
fee.

@item You may modify your copy or copies of the Library or any portion
of it, thus forming a work based on the Library, and copy and
distribute such modifications or work under the terms of Section 1
above, provided that you also meet all of these conditions:

@enumerate a
@item The modified work must itself be a software library.

@item You must cause the files modified to carry prominent notices
    stating that you changed the files and the date of any change.

@item You must cause the whole of the work to be licensed at no
    charge to all third parties under the terms of this License.

@item If a facility in the modified Library refers to a function or a 
table of data to be supplied by an application program that uses
the facility, other than as an argument passed when the facility is
invoked, then you must make a good faith effort to ensure that, in the
event an application does not supply such function or table, the
facility still operates, and performs whatever part of its purpose
remains meaningful.

    (For example, a function in a library to compute square roots has
    a purpose that is entirely well-defined independent of the
    application.  Therefore, Subsection 2d requires that any
    application-supplied function or table used by this function must
    be optional: if the application does not supply it, the square
    root function must still compute square roots.)
@end enumerate

These requirements apply to the modified work as a whole.  If
identifiable sections of that work are not derived from the Library,
and can be reasonably considered independent and separate works in
themselves, then this License, and its terms, do not apply to those
sections when you distribute them as separate works.  But when you
distribute the same sections as part of a whole which is a work based
on the Library, the distribution of the whole must be on the terms of
this License, whose permissions for other licensees extend to the
entire whole, and thus to each and every part regardless of who wrote
it.

Thus, it is not the intent of this section to claim rights or contest
your rights to work written entirely by you; rather, the intent is to
exercise the right to control the distribution of derivative or
collective works based on the Library.

In addition, mere aggregation of another work not based on the Library
with the Library (or with a work based on the Library) on a volume of
a storage or distribution medium does not bring the other work under
the scope of this License.

@item You may opt to apply the terms of the ordinary GNU General Public
License instead of this License to a given copy of the Library.  To do
this, you must alter all the notices that refer to this License, so
that they refer to the ordinary GNU General Public License, version 2,
instead of to this License.  (If a newer version than version 2 of the
ordinary GNU General Public License has appeared, then you can specify
that version instead if you wish.)  Do not make any other change in
these notices.

  Once this change is made in a given copy, it is irreversible for
that copy, so the ordinary GNU General Public License applies to all
subsequent copies and derivative works made from that copy.

  This option is useful when you wish to copy part of the code of
the Library into a program that is not a library.

@item You may copy and distribute the Library (or a portion or
derivative of it, under Section 2) in object code or executable form
under the terms of Sections 1 and 2 above provided that you accompany
it with the complete corresponding machine-readable source code, which
must be distributed under the terms of Sections 1 and 2 above on a
medium customarily used for software interchange.

  If distribution of object code is made by offering access to copy
from a designated place, then offering equivalent access to copy the
source code from the same place satisfies the requirement to
distribute the source code, even though third parties are not
compelled to copy the source along with the object code.

@item A program that contains no derivative of any portion of the
Library, but is designed to work with the Library by being compiled or
linked with it, is called a "work that uses the Library".  Such a
work, in isolation, is not a derivative work of the Library, and
therefore falls outside the scope of this License.

  However, linking a "work that uses the Library" with the Library
creates an executable that is a derivative of the Library (because it
contains portions of the Library), rather than a "work that uses the
library".  The executable is therefore covered by this License.
Section 6 states terms for distribution of such executables.

  When a "work that uses the Library" uses material from a header file
that is part of the Library, the object code for the work may be a
derivative work of the Library even though the source code is not.
Whether this is true is especially significant if the work can be
linked without the Library, or if the work is itself a library.  The
threshold for this to be true is not precisely defined by law.

  If such an object file uses only numerical parameters, data
structure layouts and accessors, and small macros and small inline
functions (ten lines or less in length), then the use of the object
file is unrestricted, regardless of whether it is legally a derivative
work.  (Executables containing this object code plus portions of the
Library will still fall under Section 6.)

  Otherwise, if the work is a derivative of the Library, you may
distribute the object code for the work under the terms of Section 6.
Any executables containing that work also fall under Section 6,
whether or not they are linked directly with the Library itself.

@item As an exception to the Sections above, you may also combine or
link a "work that uses the Library" with the Library to produce a
work containing portions of the Library, and distribute that work
under terms of your choice, provided that the terms permit
modification of the work for the customer's own use and reverse
engineering for debugging such modifications.

  You must give prominent notice with each copy of the work that the
Library is used in it and that the Library and its use are covered by
this License.  You must supply a copy of this License.  If the work
during execution displays copyright notices, you must include the
copyright notice for the Library among them, as well as a reference
directing the user to the copy of this License.  Also, you must do one
of these things:

@enumerate a
@item Accompany the work with the complete corresponding
machine-readable source code for the Library including whatever
changes were used in the work (which must be distributed under
Sections 1 and 2 above); and, if the work is an executable linked with
the Library, with the complete machine-readable "work that uses the
Library", as object code and/or source code, so that the user can
modify the Library and then relink to produce a modified executable
containing the modified Library.  (It is understood that the user who
changes the contents of definitions files in the Library will not
necessarily be able to recompile the application to use the modified
definitions.)

@item Use a suitable shared library mechanism for linking with the
Library.  A suitable mechanism is one that (1) uses at run time a copy
of the library already present on the user's computer system, rather
than copying library functions into the executable, and (2) will
operate properly with a modified version of the library, if the user
installs one, as long as the modified version is interface-compatible
with the version that the work was made with.

@item Accompany the work with a written offer, valid for at
least three years, to give the same user the materials specified in
Subsection 6a, above, for a charge no more than the cost of performing
this distribution.

@item If distribution of the work is made by offering access to copy
from a designated place, offer equivalent access to copy the above
specified materials from the same place.

@item Verify that the user has already received a copy of these
materials or that you have already sent this user a copy.

@end enumerate

  For an executable, the required form of the "work that uses the
Library" must include any data and utility programs needed for
reproducing the executable from it.  However, as a special exception,
the materials to be distributed need not include anything that is
normally distributed (in either source or binary form) with the major
components (compiler, kernel, and so on) of the operating system on
which the executable runs, unless that component itself accompanies
the executable.

  It may happen that this requirement contradicts the license
restrictions of other proprietary libraries that do not normally
accompany the operating system.  Such a contradiction means you cannot
use both them and the Library together in an executable that you
distribute.

@item You may place library facilities that are a work based on the
Library side-by-side in a single library together with other library
facilities not covered by this License, and distribute such a combined
library, provided that the separate distribution of the work based on
the Library and of the other library facilities is otherwise
permitted, and provided that you do these two things:

@enumerate a
@item Accompany the combined library with a copy of the same work
based on the Library, uncombined with any other library facilities.
This must be distributed under the terms of the Sections above.

@item Give prominent notice with the combined library of the fact
that part of it is a work based on the Library, and explaining where
to find the accompanying uncombined form of the same work.

@end enumerate

@item You may not copy, modify, sublicense, link with, or distribute
the Library except as expressly provided under this License.  Any
attempt otherwise to copy, modify, sublicense, link with, or
distribute the Library is void, and will automatically terminate your
rights under this License.  However, parties who have received copies,
or rights, from you under this License will not have their licenses
terminated so long as such parties remain in full compliance.

@item You are not required to accept this License, since you have not
signed it.  However, nothing else grants you permission to modify or
distribute the Library or its derivative works.  These actions are
prohibited by law if you do not accept this License.  Therefore, by
modifying or distributing the Library (or any work based on the
Library), you indicate your acceptance of this License to do so, and
all its terms and conditions for copying, distributing or modifying
the Library or works based on it.

@item Each time you redistribute the Library (or any work based on the
Library), the recipient automatically receives a license from the
original licensor to copy, distribute, link with or modify the Library
subject to these terms and conditions.  You may not impose any further
restrictions on the recipients' exercise of the rights granted herein.
You are not responsible for enforcing compliance by third parties with
this License.

@item If, as a consequence of a court judgment or allegation of patent
infringement or for any other reason (not limited to patent issues),
conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot
distribute so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you
may not distribute the Library at all.  For example, if a patent
license would not permit royalty-free redistribution of the Library by
all those who receive copies directly or indirectly through you, then
the only way you could satisfy both it and this License would be to
refrain entirely from distribution of the Library.

If any portion of this section is held invalid or unenforceable under any
particular circumstance, the balance of the section is intended to apply,
and the section as a whole is intended to apply in other circumstances.

It is not the purpose of this section to induce you to infringe any
patents or other property right claims or to contest validity of any
such claims; this section has the sole purpose of protecting the
integrity of the free software distribution system which is
implemented by public license practices.  Many people have made
generous contributions to the wide range of software distributed
through that system in reliance on consistent application of that
system; it is up to the author/donor to decide if he or she is willing
to distribute software through any other system and a licensee cannot
impose that choice.

This section is intended to make thoroughly clear what is believed to
be a consequence of the rest of this License.

@item If the distribution and/or use of the Library is restricted in
certain countries either by patents or by copyrighted interfaces, the
original copyright holder who places the Library under this License may add
an explicit geographical distribution limitation excluding those countries,
so that distribution is permitted only in or among countries not thus
excluded.  In such case, this License incorporates the limitation as if
written in the body of this License.

@item The Free Software Foundation may publish revised and/or new
versions of the Lesser General Public License from time to time.
Such new versions will be similar in spirit to the present version,
but may differ in detail to address new problems or concerns.

Each version is given a distinguishing version number.  If the Library
specifies a version number of this License which applies to it and
"any later version", you have the option of following the terms and
conditions either of that version or of any later version published by
the Free Software Foundation.  If the Library does not specify a
license version number, you may choose any version ever published by
the Free Software Foundation.

@item If you wish to incorporate parts of the Library into other free
programs whose distribution conditions are incompatible with these,
write to the author to ask for permission.  For software which is
copyrighted by the Free Software Foundation, write to the Free
Software Foundation; we sometimes make exceptions for this.  Our
decision will be guided by the two goals of preserving the free status
of all derivatives of our free software and of promoting the sharing
and reuse of software generally.

@center			    NO WARRANTY

@item BECAUSE THE LIBRARY IS LICENSED FREE OF CHARGE, THERE IS NO
WARRANTY FOR THE LIBRARY, TO THE EXTENT PERMITTED BY APPLICABLE LAW.
EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR
OTHER PARTIES PROVIDE THE LIBRARY "AS IS" WITHOUT WARRANTY OF ANY
KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE
LIBRARY IS WITH YOU.  SHOULD THE LIBRARY PROVE DEFECTIVE, YOU ASSUME
THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

@item IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN
WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY
AND/OR REDISTRIBUTE THE LIBRARY AS PERMITTED ABOVE, BE LIABLE TO YOU
FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR
CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE
LIBRARY (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A
FAILURE OF THE LIBRARY TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF
SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
DAMAGES.

@end enumerate
@center		     END OF TERMS AND CONDITIONS

@c ----------------------------------------------------------------------

@c ----------------------------------------------------------------------
@node Installation, Overview, Copying, Top
@chapter Installation

The GTO source code is built using the GNU autotools. When you unpack
the source code, the following should successfully build and install
the binaries and library. Note that you may need to become root for
@command{make install} to succeed.

@example
    sh> cd gto-x.x
    sh> ./confuigure
    sh> make
    sh> make install
@end example

If you have Maya installed, the Maya I/O plugin can be compiled. You
can give the @option{--enable-maya-plugin} argument to the configure
script to have the plugin built. See the INSTALL file at the top of
the source code tree for more information on using configure.

If you have zlib installed, configure will automatically assume you
want native compression support for the Reader/Writer library.

@menu

Operating system specific instructions

* Linux::                  GNU/Linux
* OSX::                    Mac OS X
* Windows::                Microsoft Windows 2000/XP
@end menu

@c ----------------------------------------------------------------------
@node Linux, OSX, Installation, Installation
@section GNU/Linux

The Maya plugin almost certainly requires a specific compiler for
GNU/Linux installation with Maya 4.x or 3.x. On versions of Red Hat
Linux 7.x the default compiler should be used; this should be gcc
2.96. On later versions of Red Hat, 8.x and 9.x, you will need to
install the following:

@example 
    compat-gcc-7.3-2.96.110.i386.rpm
    compat-gcc-c++-7.3-2.96.110.i386.rpm
    compat-libstdc++-7.3-2.96.110.i386.rpm
    compat-libstdc++-devel-7.3-2.96.110.i386.rpm
@end example

In that case, the compiler will be called gcc-2.96 and you will need
to do this before running configure:

@example
    sh> CC=gcc-2.96
    sh> export CC
    sh> CXX=g++-2.96
    sh> export CXX
@end example

If you are using Maya 5.x you will need to use gcc 3.1 or greater to
compile the plugin. In that case no compatibility rpms are
necessary. Alias recommends using gcc 3.2.

If you are not using the Maya plugin, or you want to use the GTO
library, but using a different compiler, you may need to run the build
and installation process more than once with different compiler
settings. 

On non Red Hat or home grown GNU/Linux systems, the library and binary
tools should build and install using the normal proceedure. Here at
Tweak, we typically build the library and binary tools using gcc 3.1
or greater.

@c ----------------------------------------------------------------------
@node OSX, Windows, Linux, Installation
@section Mac OS X

The GTO library and binaries should build normally on OS X if you have
installed the developer tools. You should have a version of the
developer tools that uses gcc 3.1 or better.

At the time of this writing, IBM has just released the XL compilers
for OS X. We have not yet attempted to compile the GTO tools and
library using this compiler.

The Maya plugin on Mac OS X requires the use of CodeWarrior to compile
a CFM shared object for Maya versions 4.x and 5.x. In addition, for
the 4.x versions, you will need to hack the CodeWarrior system header
files to get the build to work. We have not had much success in
getting the plugin to compile for OS X since the header munging
instructions did not work for us. However, there is no reason to
suspect that givin the proper CodeWarrior version and modifications
that it would not compile.

We would be very obliged if someone figures out how to get that to
work.

@c ----------------------------------------------------------------------
@node Windows,  , OSX, Installation
@section Microsoft Windows 2000/XP

In theory, you can compile the library and binary tools using the
Cygwin environment and gcc 3.x but we have not tested it.

Maya on Windows requires the use of Visual C++. This compiler does not
come close to complying with the ANSI C++ standard and requires many
work arounds to compile the GTO library and Maya plugin. Because of
this, the library and tools are currently unsupported on Windows.

Your mileage may vary for other Windows compilers.

@c ----------------------------------------------------------------------
@c ----------------------------------------------------------------------
     
@node Overview, Format, Installation, Top
@chapter Overview

The GTO format's primary usage is storage of static geometric
data. The types of data you might find in a GTO file are things like
polygonal meshes, various types of subdivision surfaces, NURBS or UBS
surfaces, coordinate systems, hierarchies of objects, material
bindings, and even images.

In our facility -- Tweak Films -- the data in GTO files are rendered
directly by entropy (a prman compatible rib renderer) and used for
modeling and 3D paint. We also use the GTO format in place of the
venerable and yet nasty PDB file format for particles.

From a historic point of view, the GTO file format is most closely
related to the original inventor file format, the Stanford PLY format
and the PDB particle format. Like the Wavefont PDB file format, there
are a limited number of simple GTO data types (float, int, string,
boolean). Like the inventor file format, a GTO can hold an entire
transformation hierarchy including geometric leaf nodes. Like the PLY
format, the GTO format can contain an arbitrary amount of data per
primitive. Most importantly however, the GTO file format is intended
to be very OBJ-like; its relatively easy to read and write and easy to
ignore data you don't want or know about.

GTO files are binary files. There is currently no ASCII/Unicode or
other human readable version of the file other than the output of the
@command{gtoinfo} program. Therefore we provide code for the binary
format to give implementors a head start. The file is either big or
little endian on disk, but should be readable on any platform.

The GTO reader we provide can be use libz, so it can read and write
compressed files natively. We find that compressed GTO files created
by most 3D programs are approximately 60% leaner than uncompressed
files.

The file itself contains Objects which are composed of
Components. Components are further composed of Properties. A Property
contains an array of one of the predefined data types with a specified
width. For example, you might have an object which looks something
like this:

@example

    Object "cube"
        Component "points"
            Property float[3][8] "position"
            Property float[1][8] "mass"
        Component "elements"
            Property byte[1][8] "type"
            Property short[1][8] "size"
        Component "indices"
            Property int[1][32] "vertex"
@end example

Using the terminology above, the object ``cube'' contains five
properties: ``position'', ``mass'', ``type'', ``size'', and
``vertex''. The ``points'' component describes the points that make up
the cube vertices. Each point has a position and mass stored in
properties of the same name. The position property data is composed of
eight float[3] data items (or 8 3D points). The ``mass'' property is
composed of a 8 scalar floating point values (one for each point).

The ``elements'' component contains two properties. ``type'' indicates
the type of the element (for example, triangle, quad, or triangle
strip). In this case the elements might all be quads. ``size''
indicates the number of vertices in each of the eight faces (elements)
of the cube -- (4 for a cube). The ``vertex'' property of the
``indices'' component contains the actual indices: 4 per face for a
total of 32.

Of course you could store much more data with the cube object if you
wanted to. For example, if you wanted velocity or color per point,
this would be another property in the ``points'' component. 

The meaning of this data is another story altogether. Its all handled
by protocol. One application may store things in the GTO file that
another application has no method of interpreting even though it can
read that data and modify it. In the example above, you need to know
to expect that polygonal data is stored in the given properties. The
same data could be stored with different property names and a more
complex layout. (The ``polygon'' protocol described later in this
document is different and more involved than the above example.)

@c ----------------------------------------------------------------------
@c ----------------------------------------------------------------------

@node Format, Types, Overview, Top
@chapter Format

The GTO file has six major sections which appear in the following
order. 

@enumerate

@item
@strong{Header} (Gto::Header). The header structure contains the GTO
magic number (used to determine endianness), the version of the GTO
specification that the file was written as, and the number of top
level objects in the file. There is one instance of a header in the
file. Finally, the header indicates how many strings are in the string
table.

@example

    Magic = 0x0000029f;
    Cigam = 0x9f020000; // means the file is opposite endianess

    struct Header
    @{
        uint32      magic;
        uint32      numStrings;
        uint32      numObjects;
        uint32      version;
        uint32      flags;              // reserved;
    @};
@end example

@item
@strong{String Table}. After the header, null terminated strings are
written in the file. The order of these strings is important. All
names and string properties store indices into the string table
instead of actual strings. In order to read the file properly, the
string table must be available until the file is completely
read. (Unless you don't care about any strings!)

The index number refers the string number in the table not its byte
offset. So the string index 9 (for example) refers to the 10th string
in the table (string index 0 is the first string in the table).

@item
@strong{ObjectHeader} (Gto::ObjectHeader). The object header indicates
what kind of protocol to use to interpret it, the object name and the
number of components. (More on the @strong{object} protocol
later). The name -- like all strings in the GTO file -- is stored as a
string table entry. If the file header indicated N objects in the
file, there will be N ObjectHeaders.

@example

    struct ObjectHeader
    @{
        uint32      name;               // a string table index
        uint32      protocolName;       // a string table index
        uint32      protocolVersion;
        uint32      numComponents;
    @};

@end example


@item
@strong{ComponentHeader} (Gto::ComponentHeader). Like the
ObjectHeaders the ComponentHeaders will appear together for all
objects in order. The component header indicates the number of
properties in the component and the name of the component.

@example

    enum ComponentFlags
    @{
        Transposed  = 1 << 0,
        Matrix      = 1 << 1,
    @};

    struct ComponentHeader
    @{
        uint32      name;               // a string table index
        uint32      numProperties;
        uint32      flags;
    @};

@end example

@item
@strong{PropertyHeader} (Gto::PropertyHeader). The PropertyHeaders,
like the object and component headers, appear en masse in the
file. The PropertyHeader contains the name, size, type, and dimension
of the property.

@example

    enum DataType
    @{
        Int,                // int32
        Float,              // float32
        Double,             // float64
        Half,               // float16
        String,             // string table indices
        Boolean,            // bit
        Short,              // uint16
        Byte                // uint8
    @};


    struct PropertyHeader
    @{
        uint32      name;   // string table index
        uint32      size;
        uint32      type;   // DataType enum value
        uint32      width;
    @};

@end example

@item
@strong{Data}. The last section of the file contains all of the
property data. The beginning and end of a properties data are not
marked. The size must be consistant with the description of the
property used in the PropertyHeader.

@end enumerate

In (Text) diagram form the file looks something like this:

@example

    +------------------+
    | File Header      |
    +------------------+
    | String Table     |
    +------------------+
    | Object Header    |
    |       .          |
    |       .          |
    |       .          |
    +------------------+
    | Component Header |
    |       .          |
    |       .          |
    |       .          |
    +------------------+
    | Property Header  |
    |       .          |
    |       .          |
    |       .          |
    +------------------+
    | Property Data    |
    |       .          |
    |       .          |
    |       .          |
    +------------------+


@end example

@c ----------------------------------------------------------------------
@c ----------------------------------------------------------------------
     
@node    Types, Protocols, Format, Top
@chapter Types of Property Data.

The GTO format pre-defines a small number of data types that can be
stored as properties. The currently defined types are:

@deftp {Property Type} double
64 bit IEEE floating point.
@end deftp

@deftp {Property Type} float
32 bit IEEE floating point.
@end deftp

@deftp {Property Type} half
16 bit ``IEEE floating point'' number as defined by ILM's OpenEXR
Imath library half data type. You can find links to source code and
documentation at @url{http://www.openexr.org/}.
@end deftp

@deftp {Property Type} int
32 bit signed integer.
@end deftp

@deftp {Property Type} short
16 bit unsigned integer.
@end deftp

@deftp {Property Type} byte
8 bit unsigned integer.
@end deftp

@deftp {Property Type} bool
Bit or bit vector. Not currently implemented.
@end deftp

@deftp {Property Type} string
The string type is stored as a 32 bit integer index into the GTO
file's string table. So storing a lot of strings (especially if there
is a lot of redundancy) is reasonably cheap. All strings in the GTO
file are stored in this manner.
@end deftp

Each of these data types can be made into a vector of that type. For
example the float data type can be made into a point @code{float[3]}
or a matrix @code{float[16]}. To store a scalar element the size of
the vector is 1.  (e.g. @code{float[1]}).

In this document, the types are all specified as 2 dimensional arrays
ala the C programming language. Here is a complete list of example
type forms:

@itemize @bullet
@item
@code{float[3]} - the float triple type.
@item
@code{float[1][1]} - a single floating point number.
@item
@code{float[3][]} - any number of float triples.
@item
@code{float[3][3]} - three float triples.
@item
@code{float[16][]} - any number of a 16 float (4x4 matrix) elements.

@end itemize


@c ----------------------------------------------------------------------
@c ----------------------------------------------------------------------

@node Protocols, Names, Types, Top
@chapter Protocols

The Object data interpretation is not defined by the GTO
format. However, there are currently some protocols in use that are
well defined and these are documented here. Caveat emptor: gto files
in the wild may contain more data than these protocols define, but
they presumably will obey the protocol if they indicate it by
name. It's also possible that some objects may obey more than one
protocol yet only indicate that they follow one. Unfortunately, some
protocols also specify optional components and properties in case all
of this was not confusing enough.

Protocols also have a version number. The version number is an
integer; there are no sub-versions. If there are significant changes
to a protocol, the version number should be bumped. The version number
is not meant as a method of making alternate protocols with the same
name. We have had to make three modifications to the protocols since
the file format was invented; one to the polygon protocol and one to
the transform protocol, and the introduction of a new protcol
(connections). The changes are documented in those sections.

In this document, properties are all named ``comp.prop'', where
``comp'' is the name of the component the property belongs to and
``prop'' is the name of the property. This is done to prevent
ambiguity when two different properties in different components but
with the same name exist. In the GTO file and when using the reader
library only the property name will appear.

There are two kinds of protocols: major and minor. Every object must
have a major protocol that's stored in the ObjectHeader -- this is the
main indicator of how to interpret the object data. In addition, the
object may also have several minor protocols. These indicate optional
data and how to interprete it. The next section describes how these
are stored in the file.

@menu

Major (Object) Protocols

* Object::                The Kitchen Sink of protocols.
* Coordinate Systems::    Coordinate System / Transforms.
* Particles::             Particles are easy -- supposedly.
* NURBS Surfaces::        NURBS and fewer letter (UBS) surfaces.
* Polygonal Surfaces::    Polygons, in all their gory mess.
* Subdivision Surfaces::  Catmull-Clark and Loop surfaces.
* Image::                 Image Object.
* Material::              @strong{PROPOSED} Material definition.
* Group::                 @strong{PROPOSED} Object grouping.

* Inter-Object::          Object Relationship Information.

Minor Protocols

* Difference::            Difference Files.
* Sorted Shells::         Special ordering for Polygonal Surfaces.
* Channels::              Texture and other data mapped to surfaces, etc.

@end menu

@c ----------------------------------------------------------------------

@node Object, Coordinate Systems, Protocols, Protocols
@section Object Protocol

The name of the protocol as it appears in the ObjectHeader is
``object'' version 1. The protocol does not require any other
protocols.  Here it is:

@deftypevr {Required Component} {} {object}
A container for properties which don't fit into other component
catagories well. A catch-all data ``per-object'' component.
@end deftypevr

@deftypevr {Optional Property} {string[1][1]} {object.name}
The name of the object. This name should be identical to the name in
the ObjectHeader.
@end deftypevr

@deftypevr {Optional Property} {string[1][]} {object.protocol}
Additional protocols. This property may contain the main protocol name
and any other minor protocols that the object adheres to. If a
protocol name appears in this property, the object must adhere to that
protocol. Its not an error for a program to output this property with
only the major protocol as its value; this is of course redundant
since the protocol name is required by the ObjectHeader. It is also
not an error for this property to exist but contain nothing.
@end deftypevr

@deftypevr {Optional Property} {int[1][]} {object.protocolVersion}
Additional protocol version numbers. This property may exist if the
@strong{object.protocol} property exists. Each entry in this property
corresponds to the same entry indexed in the @strong{object.protocol}
property. This property must contain the same number of elements that
the @strong{object.protocol} property does.
@end deftypevr

You may be asking why the @strong{object} protocol exists at all. The
name of an object is stored in the ObjectHeader in the file and in the
C++ library is passed to the reader code. The ``name'' property is
redundant right? Well yes. But some programs will output the name both
in the ObjectHeader and in an @strong{object} component as the
property ``name''.

The main point of this protocol is to define the @strong{object}
component. This component is meant to hold data that is ``per object''
and which doesn't really fit neatly into other components. The name is
one such case. The coordinate system protocol also defines properties
in the @strong{object} component and the minor protocols are
optionally stored here.

@c ----------------------------------------------------------------------

@node Coordinate Systems, Particles, Object, Protocols
@section Coordinate System Protocol

The name of the protocol as it appears in the ObjectHeader is
``transform'' version 3@footnote{In version 1, the transform protocol's
object.globalMatrix property used to be of type
@code{float[1][16]}. This was a mistake that has been corrected in
version 2.}. The protocol requires the @strong{object} protocol. Objects
which obey the @strong{transform} protocol will have global matrices and
possibly a parent.

@deftypevr {Required Component} {} {object}
From the "object" protocol.
@end deftypevr

@deftypevr {Required Property} {float[16][1]}  {object.globalMatrix}
A 4x4 matrix of floating point numbers. This matrix describes the
world matrix of the coordinate system.
@end deftypevr

@deftypevr {Optional Property} {string[1][1]}  {object.parent}
The name of an object to which this coordinate system is
parented. Presumably this object (if it appears in the gto file) will
also obey the @strong{transform} protocol. If this property does not
exist or the name is ``'' (the empty string) then the coordinate
system presumably is a root coordinate system.@footnote{In version 3
of the @strong{transform} protocol, the @strong{object.parent}
property is redundant and therefor deprecated. The
@strong{connection} protocol
handles the transformation hierarchy information and in a much more
elegant manner @xref{Inter-Object}.}
@end deftypevr

@c ----------------------------------------------------------------------

@node Particles, NURBS Surfaces, Coordinate Systems, Protocols
@section Particle Protocol

The name of the protocol as it appears in the ObjectHeader is
``particle'' version 1. The protocol may include the @strong{object} and
@strong{transform} protocols.

@deftypevr {Required Component} {} {points}
The points component is transposable. That means that all of its
properties are required to have the same number of elements. 
@end deftypevr

@deftypevr {Optional Property} {float[3][]} {points.position} 
@deftypevrx {Optional Property} {float[4][]} {points.position}
The position property is intended to hold the position of the particle
in its own coordinate system or world space if it has no coordinate
system. The element is either a 3D or 4D (homogeneous) point.
@end deftypevr

@deftypevr {Optional Property} {float[3][]} {points.velocity}
The velocity property -- if it exists -- should hold the velocity
vector per-point in the same coordinate system that the ``position''
property is in.
@end deftypevr

@deftypevr {Optional Property} {int[1][]}  {points.id}
The ``id'' property should it exist will @emph{always} be defined as
an integer per particle (or other integral type if it ever
changes). This number should be unique for each particle. Ideally,
multiple GTO files with a point that has the same ``id'' property for
a given particle animation @emph{should} be the same particle. 
@end deftypevr

The @strong{particle} protocol defines the @strong{points} component
that many other protocols are derived from. For example, the
@strong{NURBS} protocol uses the points defined by the particle
protocol as control vertices. There can be any number of properties
associated with particles including string per-particle.

The @strong{points} component is marked transposable in the its
ComponentHeader. This means that the properties in the component are
guaranteed to have the same number of elements. Because of this, the
data for the properties in a transposable component may be stored
differently than other components. For example, the normal state of
affairs is to write data like this:

@example
        position0 position1 position2 .... positionN
        velocity0 velocity1 velocity2 .... velocityN
        mass0 mass1 mass2 .... massN
@end example

So that you must read through all of the particle positions before you
can read the first particle's velocity. But this is not usually the best
way to read particle data for rendering. You may want to cull the
particles as you read them without storing the data. In order to do
this the data needs to be laid out like this:

@example
        position0 velocity0 mass0
        position1 velocity1 mass1
        position2 velocity2 mass2
        ...
@end example

In this case, each particle is scanned in one chunk allowing for
optimizations. Obviously this complicates reading, but in the case of
giga-particle renderers, this can be a huge memory savings.

@c ----------------------------------------------------------------------

@node NURBS Surfaces, Polygonal Surfaces, Particles, Protocols
@section NURBS Protocol

The name of the protocol as it appears in the ObjectHeader is
``NURBS'' version 1. The protocol requires the @strong{particle} protocol
and optionally includes the @strong{object} and @strong{transform} protocols.

@deftypevr {Required Component} {} {points}
see @strong{particle} protocol. The points describe data per NURBS control
vertex.
@end deftypevr

@deftypevr {Required Property} {float[3][]} {points.position}
@deftypevrx {Required Property} {float[4][]} {points.position}
The position property holds the control point positions in its own
coordinate system or world space if it has no coordinate system. The
element is either a 3D or 4D (homogeneous) point. If the type is
float[4] the fourth component of the element will be the rational
component of the control point position. The control points are laid
out in @strong{@var{v}-major} order (@var{u} iterates more quickly than
@var{v}).
@end deftypevr

@deftypevr {Optional Property} {float[1][]} {points.weight}
If the position property is of type @code{float[3][]} there may
optionally be a ``weight'' property. This property holds the
homogeneous (rational) component of the position. Older GTO writers
may export data in this manner. The preferred method is to use a
@code{float[4]} element position.
@end deftypevr

@deftypevr {Required Component} {} {surface}
Properties related to the definition of a NURBS surface are stored in
this component.
@end deftypevr

@deftypevr {Required Property} {float[1][2]} {surface.degree}
The degree of the surface in @var{u} and @var{v}.
@end deftypevr

@deftypevr {Required Property} {float[1][]} {surface.uKnots}
@deftypevrx {Required Property} {float[1][]} {surface.vKnots}
The NURBS surface knot vectors in @var{u} and @var{v} are stored in
these properties. The knots are not piled. The usual NURBS
restrictions on how numbers may be stored in the knot vectors apply.
@end deftypevr

@deftypevr {Required Property} {float[1][2]} {surface.uRange}
@deftypevrx {Required Property} {float[1][2]} {surface.vRange}
The range of the knot parameters in @var{u} and @var{v}.
@end deftypevr

The @strong{NURBS} protocol currently does not handle trim curves, points on
surface, etc. Ultimately, the intent is to handle the trim curves and
other nasties as NURBS curves-on-surface which will be stored in
additional components. UBS surfaces can be stored as NURBS with
non-rational uniform knots.

@c ----------------------------------------------------------------------

@node Polygonal Surfaces, Subdivision Surfaces, NURBS Surfaces, Protocols
@section Polygon Protocol

The name of the protocol as it appears in the ObjectHeader is
``polygon'' version 2@footnote{In version 1 of the polygon protocol,
the @strong{element.size} and @strong{element.type} properties were
combined into an @strong{element.primitive} property. We felt that
this was adding unnecessary complexity and because the primitive
property was an int, it was taking up extra space.}. The protocol
requires the @strong{particle} protocol and optionally includes the
@strong{object} and @strong{transform} protocols.

There are a number of alternative configurations of this protocol
depending on the value of the @strong{smoothing.method} property. All
of these involve the placement of normals in the file.

@deftypevr {Required Component} {} {points}
See @strong{particle} protocol. The points describe data per vertex.
@end deftypevr

@deftypevr {Required Property} {float[3][]} {points.position}
The positions for regular polygonal meshes are stored as
@code{float[3]}. 
@end deftypevr

@deftypevr {Optional Property} {float[3][]} {points.normal}
Normals per vertex. The @strong{smoothing.method} property will have
the value of @emph{Smooth} if this property exists. Note that use of
the @emph{Smooth} smoothing method does not require that this property
exists. If it does not the method is merely and indication of how the
normals should be constructed. 
@end deftypevr

@deftypevr {Optional Component} {} {normals}
This component will exist if the value of @strong{smoothing.method} is
@emph{Partitioned} or @emph{Discontinuous}.
@end deftypevr

@deftypevr {Required Property} {float[3][]} {normals.normal}
This property is required only if the @strong{normals} component
exists and the value of @strong{smoothing.method} is
@emph{Partitioned} or @emph{Discontinuous}.
@end deftypevr


@deftypevr {Required Component} {} {elements} 
The elements component is
transposable. All properties in the elements component must have the same
number of elements. Each element corresponds to a polygonal primitive.  
@end deftypevr

@deftypevr {Required Property} {byte[1][]} {elements.type}
Elements are modeled after the OpenGL primitives of the same name. The
vertex order is identical to that defined by GL. The type numbers
outside those given here are not defined but reserved for future
use. So far, these are the define type numbers:

    @table @strong
    @item 0 -- Polygon
    General N-sided polygon. This can be used for any polygon that has 3 or more vertices.

    @item 1 -- Triangle
    A three vertex polygon.

    @item 2 -- Quad
    A four vertex polygon.

    @item 3 -- TStrip
    Triangle strip.

    @item 4 -- QStrip
    Quad strip. 

    @item 5 -- Fan
    Triangle fan. 

    @end table

@end deftypevr

@deftypevr {Required Property} {short[1][]} {elements.size}
The size of each primitive. Because the type is short, there is a
limit of 65k veritices per primitive.
@end deftypevr

@deftypevr {Optional Property} {short[1][]} {elements.smoothingGroup}
This property may exist if the value of @strong{smoothing.method} is
@emph{Partitioned}. In that case, this property indicates the
smoothing group number associated with each element. These can be used
to recompute the normals. These numbers are the same as those found in
the Wavefront .obj file format's ``s'' statements. A value of 0
indicates that an element is not in a smoothing group.
@end deftypevr

@deftypevr {Optional Property} {float[3][]} {elements.normal}
Normals per element. The @strong{smoothing.method} property will have
the value of @emph{Faceted} if this property exists. Note: the use of
@emph{Faceted} smoothing method does not require that this property
exists. If it does not, the smoothing method is merely and indication
of how the normals should be created.
@end deftypevr

@deftypevr {Required Component} {} {indices}
The indices component is transposable. All of its properties are
required to have the same number of elements. Each entry in the
indices component corresponds to a polygonal vertex.@footnote{The
@strong{indices} component in a polygonal object contains values which
are analogous to the RenderMan @code{facevarying} type modifier.}
@end deftypevr

@deftypevr {Required Property} {int[1][]} {indices.vertex}
A list of all the polygonal vertex indices in the same order as the
@strong{elements.primtives}. The indices refer to the @strong{points.position}
property. So if the first polygonal element is a triangle and second
is a general four vertex polygon then vertex indices will be something
like:

@example
    0 1 2 1 0 3 4 ...
@end example

which would be grouped as:

@example
    (0 1 2) (1 0 3 4) ...
@end example

The first group is the triangle and the second the polygon.
@end deftypevr

@deftypevr {Optional Property} {int[1][]} {indices.st}
Similar to the vertex indices but indicates indices into @var{st}
coordinates. These are usually stored in the ``mappings'' component
but may also appear in the @strong{points} component. 
@end deftypevr

@deftypevr {Optional Property} {int[1][]} {indices.normal}
Indices into stored normals if there are any. The
@strong{smoothing.method} property will have the value of
@emph{Partitioned} or @emph{Discontinuous} if this property exists.
@end deftypevr

@deftypevr {Optional Component} {} {mappings}
Contains parametric coordinates. The property names in mappings
usually correspond to names found in the @strong{indices} component
but not always. For example @strong{mappings.st} would be a
@code{float[2][]} property holding texture coordinates indexed by
@strong{indices.st}.
@end deftypevr

@deftypevr {Optional Component} {} {smoothing}
The smoothing component exists to hold the smoothing method and any
ancillary data for the method. If there is no smoothing component (and
hence no @strong{smoothing}) you can assume anything you want.
@end deftypevr

@deftypevr {Required Property} {int[1][1]} {smoothing}
There five defined smoothing methods (0 through 4). They are:

@c for some reason, makeinfo doesn't format the table text correctly
@c if the lines are broken. So I ran them all together. pdftex does
@c just fine either way

    @table @strong
    @item 0 -- None
    No smoothing method specified. No additional properties associated with normals will appear in the object.

    @item 1 -- Smooth 

    One normal at every vertex. There will be a @code{float[3][]} @strong{normal} property as part of the @strong{points} component. Each vertex has a unique normal.

    @item 2 -- Faceted

    One normal for each face. There will be a @code{float[3][]} @strong{normal} property in the @strong{elements} component. Each element has a unique normal.

    @item 3 -- Partitioned

    Same as the Wavefront .obj smoothing groups. There will be a @strong{normals} component containing a @code{float[3][]} @strong{normal} property and an @code{int[1][]} @strong{normal} propery in the @strong{indices} component. Each element vertex will have an index into the @strong{normals.normal} property.

    @item 4 -- Discontinuous

    Like @emph{Partitioned} but with additional lines and points of discontinuity. The same properties that hold the @emph{Partitioned} information will hold the @emph{Discontinuous} information. There will also be a component called @strong{discontinuities} which will have a @code{int[1][]} property called @strong{indices} indicating the points and lines of discontinuity.

    @end table

@end deftypevr

@c ----------------------------------------------------------------------

@node Subdivision Surfaces, Image, Polygonal Surfaces, Protocols
@section Subdivision Surface Protocols

The name of the protocol as it appears in the ObjectHeader is
``catmull-clark'' or ``loop'' depending on the intended subdivision
scheme. The protocol requires the @strong{polygon} protocol.

The smoothing and any normals properties on the @strong{polygon} protocol
should be ignored if they exist.

The protocol indicates how the surface should be treated. Note that
the canonical element type for each of the two schemes is not
guaranteed to be the only element type stored in the file. For
catmull-clark this means that triangles and general polygons will
need to be made into quads. Similarily loop surfaces may have
quads and other non-triangle primitives that need to be triangulated.

These protocols do not currently define methods for storing edge
creasing parameters.

Disclaimer: there are restrictions on what kind of topology surfaces
are allowed to have for a given renderer (for example). In most cases
surfaces need to be manifold. Some applications can deal with special
cases better than others.

@c ----------------------------------------------------------------------

@node Image, Material, Subdivision Surfaces, Protocols
@section Image Protocol

The Image protocol describes image data in the form of an object. This
data makes it possible to store texture maps, backgrounds, etc,
directly in the GTO file. The GTO format is not intended as a general
purpose image file format. Better formats for general purpose image
storage are TIFF and OpenEXR.  

When images are stored in a GTO file, use of Gzip compression is
highly recommended since this protocol specifies no compression
itself. As of version 2.1, the supplied Reader and Writer classes
default to using zlib compression.

@deftypevr {Required Component} {} {image}
The image data and other information will be stored in the
@strong{image} component.
@end deftypevr

@deftypevr {Required Property} {int[1][]} {image.size}
The size (and dimension) of the image. There will be N sizes in this
property corresponding to the N dimensions of the image.
@end deftypevr

@deftypevr {Required Property} {string[1][1]} {image.type}
The image type. For interactive purposes, the image channels may
correspond to a particular fast hardware layout.

@itemize @bullet
@item @code{RGB}
Three channels corresponding to red, green, and blue in that order.
@item @code{BGR}
Three channels corresponding to blue, green, and red in that order.
@item @code{RGBA}
Four channels corresponding to red, green, blue, and alpha in that
order.
@item @code{ABGR}
Four channels corresponding to alpha, blue, green, and red in that
order.
@item @code{L}
One channel corresponding to luminance.
@item @code{HSV}
Three channels corresponding to hue, saturation, and value. (The HSV
color space).
@item @code{HSL}
Three channels corresponding to hue, saturation, and lightness. (The
HSL color space).
@item @code{YUV}
Three channels corresponding to the YUV color space.
@end itemize
@end deftypevr


@deftypevr {Optional Property} {int[1]} {image.cs}
The coordinate system of the image. The value of @strong{image.cs} can
be any one of the following:

@table @strong
    @item 0 -- Lower left origin.
The first pixel in the image data is the lower left corner of the
image data and corresponds to NDC coordinate (0,0). 

    @item 1 -- Upper left origin.
The first pixel in the image data is the upper left corner of the
image data and corresponds to NDC coordinate (0,0).
@end table
@end deftypevr

Any one of the following properties are required to hold the actual
image data:

@deftypevr  {Property} {byte[N][]} {image.pixels}
@deftypevrx {Property} {short[N][]} {image.pixels}
@deftypevrx {Property} {half[N][]} {image.pixels}
@deftypevrx {Property} {float[N][]} {image.pixels}
The element width determines the number of channels in the image. For
example, the type @code{byte[3][]} indicate a 3 channel 8-bit per
channel image. The number of elements in this property should be equal
to @code{image.size[0] * image.size[1] * ... image.size[N]} where
@strong{image.size} is the property defined above.
@end deftypevr


@c ----------------------------------------------------------------------

@node Material, Group, Image, Protocols
@section @strong{PROPOSED} Material Protocol

The name of the protocol as it appears in the ObjectHeader is
``material''. The material protocol groups a parameters and a method
(shader) for rendering. The material protocol can optionally include
the @strong{object} protocol.

The material definition is renderer and pipeline dependant. Material
assignment is implemented using the @strong{connection}
protocol. @xref{Inter-Object}.

The @strong{material} protocol is intended for use with software
renderers. Interactive material definitions may be more easily defined
on the assigned object.

@deftypevr {Required Component} {} {material}
Properties unrelated to parameters appear in the @strong{material}
component. 
@end deftypevr

@deftypevr {Required Property} {string[1][1]} type
The value of the @strong{material.type} property is renderer
dependant. For a RIB renderer, the value of type might be ``Surface'',
``Displacement'', ``Atmosphere'' or a similar shader type name. 
@end deftypevr

@deftypevr {Optional Property} {string[1][1]} shader
The name of the shader. For RenderMan-like renderers this might be the
name of an ``.sl'' file.
@end deftypevr

@deftypevr {Optional Property} {string[1][1]} genre
A property to further identify the material. This is most useful for
identifying the target renderer for a material.
@end deftypevr

@deftypevr {Optional Component} {} {parameters}
The set of parameters corresponding to the @strong{material.type}. 
@end deftypevr


@c ----------------------------------------------------------------------

@node Group, Inter-Object, Material, Protocols
@section @strong{PROPOSED} Group Protocol


@c ----------------------------------------------------------------------
@node Inter-Object, Difference, Group, Protocols
@section Inter-Object Connection Protocol

The name of the protocol as it appears in the ObjectHeader is
``connection'' version 1. 

Files which employ the @strong{connection} protocol will typically
contain a connection object with the special cookie name
``:connections'' indicating the purpose of the object as well as
preventing namespace pollution. @xref{Special Cookies}.

Each component in a connection object is a connection type. For
example, the ``parent_of'' connection type is used to represent
transformation hierarchies. In a connection object, there will be a
single component called ``parent_of'' which will contain the required
properties @strong{parent_of.lhs} and @strong{parent_of.rhs} at a
minimum. Some connection types may have additional data in the form of
additional properties. 

Connection components are transposable. The number of elements in
properties comprising a connection component will be consistant. So a
single ``parent_of'' component can encode an entire scene
transformation hierarchy.

Connection components have the following properties. Note that where
@strong{connection_type} occurs in the property name, you would
substitute in the actual name of the connection
type. (``parent_of'' for example).

@deftypevr  {Required Property} {string[1][]} {connection_type.lhs}
@deftypevrx {Required Property} {string[1][]} {connection_type.rhs}
The left-hand-side and right-hand-side of the connection. 

@itemize @bullet
@item
If the connection is directinal, then an arrow indicating the
direction would have its tail on the left-hand-side and its head
pointing at the right-hand-side.

@item
If the connection type does not require a direction then these
properties are still used to describe the two ends of the
connection. 

@item
Each entry will be the name of an object. There is no requirement that
the ends of the connection exist in the file. For example, one end of
the connection could be an image on disk. 

@item
The empty string is a valid value. You could think of the empty string
as indicating a grounded connection. 

@item
Its ok for both ends of the connection to have the same value.
@end itemize

@end deftypevr

The GTO specification includes a couple of basic connection types.

@menu
Connection Types Defined by the Spec

* parent_of::             Transformation hierarcies.
* material::              @strong{PROPOSED} Material assignments.
* contains::              @strong{PROPOSED} Group/Container assignment.

@end menu

@c ----------------------------------------
@node parent_of, material, Inter-Object, Inter-Object
@subsection Transformation hierarchies.

The ``parent_of'' connection type is used to store transformation
hierarchies. The connection type requires only the @strong{lhs} and
@strong{rhs} properties. Transformation hierarchies are usually tree
structures, but can also be DAGs (as is the case with Maya or
Inventor). 

Using ``parent_of'' as a cyclic generalized network connection is
probably an error for most applications. To be safe the topology of a
``parent_of'' network should be a tree.

@c ----------------------------------------
@node material, contains, parent_of, Inter-Object
@subsection @strong{PROPOSED} Material Assignment

The ``material'' connection type indicates a material assignment to an
object. The left-hand-side name is a renderable object in a GTO file
The right-hand-side is the name of a material object in a GTO
file. 

@c ----------------------------------------
@node contains,  , material, Inter-Object
@subsection @strong{PROPOSED} Container Assignment

The ``contains'' connection type indicates membership in a group or
similar type of container object. The LHS is the group or container,
the RHS is the object which is a member.

@c ----------------------------------------------------------------------

@node Difference, Sorted Shells, Inter-Object, Protocols
@section Difference File Protocol

If the @strong{object.protocol} property contains the string
``difference'' then the object contains difference data; the data is
relative to some other reference file. 

For example, for animated deforming geometry its advantageous to write
a reference file for geometry in its natural undeformed state then
write only the @strong{points.position} property in a gto file per
frame to store animation. The @strong{difference} minor protocol can
apply to any major protocol.

If a reference file and a difference for file it exists, you can
reconstruct the file represented by the difference file using the
@command{gtomerge} command. @xref{gtomerge}.

@c ----------------------------------------------------------------------

@node Sorted Shells, Channels, Difference, Protocols
@section Sorted Shell File Protocol

If the @strong{object.protocol} property contains the string
``sorted'' and the object's major protocol is @strong{polygon} then
the object contains sorted shell data.

This protocol guarantees that the vertices and elements of shells ---
isolated sections of polygonal geometry --- will be continguous in the
@strong{points} and @strong{elements} components of the object.

@deftypevr {Required Component} {} {shells}
The @strong{shells} component is transposable. Each property in the
component should have the same number of elements. 
@end deftypevr

@deftypevr {Required Property} {int[1][]} {shells.vertices}
The number of contiguous vertices that make up the Nth element's
shell.
@end deftypevr

@deftypevr {Required Property} {int[1][]} {shells.elements}
The number of contiguous elements that make up the Nth element's
shell.
@end deftypevr

@c ----------------------------------------------------------------------

@node Channels,  , Sorted Shells, Protocols
@section Channels Protocol

This minor protocol declares data mapped onto geometric
surfaces. Usually the data is mapped using one of the
parameterizations found in the @strong{mappings} component of
polygonal or sub-d geometry or possibly using the natural
parameterization of a surface as is often the case with NURBS.

Each declared channel appears as a @code{string[1][]} property of a
@strong{channels} component on the geometry. The name of the property
is the name of the channel. The property should contain at least one
element. 

The first element of the property should indicate the name of the
mapping to use. This is either the name of one of the properties in
the @strong{mappings} component or ``natural'' indicating that the
natural parameterization of the surface should be used.

The second and subsequent elements should contain the name of data to
map. This could be a texture map file on disk, an image object in the
GTO file, or a special cookie string. The lack of second element can
be used as a special cookie.

@deftypevr {Required Component} {} {channels}
The component holds the names of all the channels on the geometry.
@end deftypevr

@subsection Example

Here is a cube with ``color'', ``specular'', and, ``bump'' channels
assigned. 

@example
    Object "cube" protocol "polygon"
        Component "points"
            Property float[3][8] "position"
        Component "elements"
            Property byte[1][8] "type"
            Property short[1][8] "size"
        Component "indices"
            Property int[1][32] "vertex"
            Property int[1][32] "st"
        Component "mappings"
            Property float[2][24] "st"
        Component "channels"
            Property string[1][2] "color"
            Property string[1][2] "specular"
            Property string[1][2] "bump"
@end example

The contents of the ``channels'' properties might be:

@example
string[1] cube.channels.color    = [ "st" "cube_color.tif" ]
string[1] cube.channels.specular = [ "st" "cube_specular.tif" ]
string[1] cube.channels.bump     = [ "st" "cube_bump.tif" ]
@end example


@c ----------------------------------------------------------------------
@c ----------------------------------------------------------------------

@node Names, Issues, Protocols, Top
@chapter Naming Conventions

GTO files can contain cross references to parts of themselves, objects
outside the file, or virtual/logical objects in applications. Because
of the potential morass that can result from complete free-form
naming, there are conventions which are part of the file
specification. 

Failure to follow the guidelines does not mean a GTO file is
ill-formed; there's always a good reason to ignore guidelines. But
having a basis for consistancy is usually a good idea.

Some of these topics are a bit ``advanced'' in that they build off
ideas that present themselves after using the file format for a
while. If you are just learning about the format, consider this a
reference section and skip it. If you're trying to decrypt a
complicated GTO file with strange garbled naming, then this section is
for you.

@menu

* Valid Names::             General Guidelines.
* Path Names::              Exactly specifying a property or component.
* Special Cookies::         Indicating special handling.
* Cross References::        Cross references encoded in names.
@end menu

@c ----------------------------------------------------------------------
@node Valid Names, Path Names, Names, Names
@section Valid Names

Names should be valid C identifiers, but should not contain the
dollar-sign character ($). This means that no whitespace or
punctuation is allowed. 

Note that this does @emph{not} apply to protocol names.

There is nothing in the sample @code{Reader} or @code{Writer} classes
which enforces the valid name guideline. However, some applications
(Maya) cannot handle names with whitespace and/or punctuation. So
plug-ins which implement GTO reading/writing will have to enforce the
application's specific naming requirements.

This guideline is broken by @ref{Special Cookies}. Its also broken by
@ref{Cross References}.

@c ----------------------------------------------------------------------
@node Path Names, Special Cookies, Valid Names, Names
@section Exactly Specifying a Property or Component

By convention, the full name or path name of a property is refered to
like this:

@example
    OBJECTNAME.COMPONENTNAME.PROPERTYNAME
@end example

When indicating a property name relative to an object then:

@example
    COMPONENTNAME.PROPERTYNAME
@end example

should suffice. In this manual, names of components and properties are
disambiguated using the dot notation. In addition, this is the format
of output from the @command{gtoinfo} command. There is nothing about
the GTO file itself which relates to this notation other than the
cross-referencing naming convention discussed below. 

@c ----------------------------------------------------------------------
@node Special Cookies, Cross References, Path Names, Names
@section Indicating Special Handling

Some objects, components, or properties in the GTO file may contain
data for which names are not particularily useful or that may simply
pollute the object or component namespace.

In other cases (component names most notably) the name may be used as
information necessary to interpret data associated with it.

In order to distinguish these names from run-of-the-mill names, you
should include a colon in the name. Names with colons are considered
``special cookie'' names and objects which have them may be handled
differently than other objects. 

The @strong{connection} object protocol, for example, requires that a
special file object exist to hold data. This object is not necessarily
related to a logical object in the application, its just a container
for the connection data. These objects are named using the special
cookie syntax. Usually the name is
``:connections''. @xref{Inter-Object}.

There is no rule regarding the placement of the colon in the name; it
can appear anywhere in the name that is useful for the
application. However, if the entire name is a special cookie --- there
is not additional information encoded in the name beyond itself ---
the recommend form is to have the colon be the first character.

@c ----------------------------------------------------------------------
@node Cross References,  , Special Cookies, Names
@section Cross References Encoded in Names

Sometimes there is a need to have a property or component @emph{refer}
to another property, component, or object in the file (or somewhere
else). 

To cross reference the data in one property with another, simply name
the property the full (or partial) path to the referenced
property. For example, here's the output of @command{gtoinfo} on a GTO
file which has cross referencing properties:

@example
object "gravity" protocol "gravity" v1
  component "field"
    property float[3][1] "direction" 
    property float[1][1] "magnitude" 
  component ":datastream"
    property float[3][300] "field.direction" 
    property float[1][300] "field.magnitude" 
@end example

As you can guess, the intention here is that the properties called
``field.direction'' and ``field.magnitude'' in the ``:datastream''
component are data that is associated with the properties
``direction'' and ``magnitude'' in the ``field'' component. 


@c -------------------------------------------------------------------------
@c -------------------------------------------------------------------------

@node Issues, Extending, Names, Top
@chapter Issues and Questionable Aspects of the Format

@itemize @bullet

@item
There is no ASCII version of a GTO file. Currently the closest thing
to that is to use the @command{gtoinfo} command to dump the contents
as ASCII. There is no program which takes that output and creates a
binary GTO file, nor is there a reader or writer class for outputing
ASCII GTO data. Ideally, there would be a dedicated ASCII format which
is as analogous as possible to the binary format as well as support
for the ASCII file type in the supplied reader and writer classes.

@item
There are currently no (publicly available) tools which verify that a
file claiming to follow some protocol is correct.

@item
There is no 3D curve(s) protocol defined.

@item
The @strong{NURBS} protocol does not handle trim curves. @xref{NURBS
Surfaces}.

@item
The format does not contain dedicated space for auxillary information
like the name and version of the program that wrote the file, the
original owner, copright information, etc. However, our tools use the
string table for these type of data -- since its not an error have an
unused interned string, we store the data as such. In our opinion,
this is a fairly innocuous method. You can read unreferenced strings
by using the @command{gtoinfo} command with the @option{-s}
option. Note that these strings are often lost when programs read and
write the file.  @xref{gtoinfo}.

@item
Although the format specification includes transposable components
(those marked with the Gto::Matrix flag may be transposed), the
current reader/writer library does not handle files with transposed
components. It does handle components that are marked as Gto::Matrix
but not transposed. @xref{Particles}.

@item
The use of special cookie names and special cross-reference names
seems to seriously complicate the format if the protocol is not
carefully conceived. For example, using @command{gtomerge} to merge
files containing connections does not work --- the connections are
merged like all the other data in the file. The correct behavior would
be to combine the connections, but merge the other object
data. Perhaps this is just a case for integrating @command{gtocombine}
into @command{gtomerge}?

@item
Future versions should incorporate some form of check sum or some
similar mechanism to do better sanity checking.

@item
There are many examples of properties whose data indexes into other
property data. The most obvious of these are the polygon protocol
@strong{indices} properties. In order to combine gto files
(concatenate polygonal data together for example) its necessary to
know which properties are indexes and which are not. Index properties
must be offset to be combined.

@item
The Boolean (bit fields) and Half data types are not implemented in
the supplied writer library. Both of these types are useful in
compressing geometric (and image) data.

@item
Material, Texture, and similar assignments and storage are usually
very specialized at any particular production facility. The idea that
a single method of encoding this information can be determined or
enforced --- or even usefully be stored in a GTO file --- is not
realistic. However, we hope that some method can be determined that at
least preserves a good portion of common data for transfer. 

All of the protocols related to these concepts are marked
@strong{PROPOSED} in this
document.
@xref{Material}. @xref{material}.

@end itemize

@c -------------------------------------------------------------------------
@c -------------------------------------------------------------------------

@node Extending, Library, Issues, Top
@chapter Extending Protocols or the File Format

If you have an extension to a protocol or would like to change an
existing protocol, we would like to hear about it. You can send mail
to @email{gto @emph{at} tweakfilms.com} with the changes you're using or would
like made. We will collect ideas and proposals and try to make
releases in a timely manner. We'd also like to hear from you if you're
using it unmodified.

There is currently a small number of facilities that use the GTO
format, but there is a large collection of tools that use it. Most
proposals should maintain some backwards compatibility. However, we
recognize that the there may be flaws that require revamping
significant pieces and we're open to making changes to accommodate
other facilities.

If you are using the format for academic purposes and are looking for
a specific tool to munge GTO files, we may already have that tool
eventhough it is not released. Contact us; we might be able to help
you out.

We have been using the format since summer 2002 on a regular basis in
production at Tweak Films and have found it stable and useful. The
version of the code we use is identical to the released version.

@c -------------------------------------------------------------------------
@c -------------------------------------------------------------------------

@node Library, Module, Extending, Top
@chapter C++ Library

The GTO Reader/Writer library is written in a subset of C++. The
intention was to make the library as portable as
possible. Unfortunately we have only tried it on platforms that
support gcc 2.95 and greater. It is known to work on various Linux
versions and Mac OS X. In either case it has been compiled with gcc.

@menu
* Reader::                      Read GTO files by deriving from the Reader.
* Writer::                      Write GTO files by using a Writer instance.
* RawData::                     RawData classes.
@end menu

@c ----------------------------------------------------------------------

@node Reader, Writer, Library, Library
@section Gto::Reader class

The Reader class (in namespace Gto) is designed as a fill-in-the-blank
API. The user of the class derives from it; the base class defines a
number of virtual functions which pass data to the derived class and
ask the derived class questions about what data it wants.

The Reader class handles most of the difficult work in reading the
file like keeping track of headers, sizes of properties, and the order
of data. In addition, it handles the string table and looking up
property string values. If the file was written by a machine with
different sex (endianess) it will translate the data for you. 

In addition, you can compile the GTO library with zlib support. This
enables the Reader class to read gzipped GTO files natively and the
Writer class to write them. This can be a significant space savings on
disk and on saturated networks can make file loading faster. You can
also pass a C++ istream object to the Reader if you want to read
``in-core''.

As the file is read, the Reader class will call its virtual functions
to declare objects in the file to the derived class. The derived class
is expected to return a non-null pointer if it wishes to later receive
data for that object.

@deftypefn {Constructor} {} Reader::Reader (unsigned int @var{mode})
The constructor @var{mode} indicates how the reader will be
used. Possible values for mode are:

@table @strong
@item Reader::None
The reader will be used in its standard @emph{streaming} mode. The
reader will attempt to read all the data in the file. This is the
default value (or 0).

@item Reader::HeaderOnly
The reader will stop once it has read the header sections of the GTO file. 

@item Reader::RandomAccess
The reader will read the header sections but not the data, however, it
will initialize for use of the @code{Reader::accessObject()} function.

@end table
    
@end deftypefn

@deftypefn {Destructor} {} Reader::~Reader ()
Closes file if still open.
@end deftypefn

@deftypefn {Method} bool Reader::open (const char* @var{filename})
Open the file. The Reader will attempt to open file 
@var{filename}.  If the file does not exist and zlib support is compiled
in, the Reader will attempt to look for @var{filename}.gz and open it instead.
@end deftypefn

@deftypefn {Method} bool Reader::open (std::istream&, const char* @var{name})
Reads the GTO file data from a stream. The @var{name} is supplied to
make error messages make sense.
@end deftypefn

@deftypefn {Method} void Reader::close ()
Close the file and clean up temporary data. If the stream constructor
was used, the stream is @emph{not} closed.
@end deftypefn

@deftypefn {Method} std::string& Reader::why ()
Returns a human readable description of why the last error occured.
@end deftypefn

@deftypefn {Method} {const std::string&} Reader::stringFromId (unsigned int)
Given a string identifier, this method will return the actual string
from the string table.
@end deftypefn

@deftypefn {Method} {const StringTable&} Reader::stringTable ()
Returns a reference to the entire string table.
@end deftypefn

@deftypefn {Method} {bool} Reader::isSwapped () const
Returns true if the file being read needed to be swapped. This occurs
if the machine the file was written on is a different sex than the
machine reading the file (for example a Mac PPC written file read on
an x86 GNU/Linux box).
@end deftypefn

The following functions return a @code{Reader::Request} object. This
object takes two parameters: a boolean indicating whether the data
in question should be read by the reader and a second optional data
@code{void*} argument of user data to associate with the file data.

@deftypefn {Constructor} {} Reader::Request::Request (bool @var{want}, void* @var{data})
@var{want} value of true indicates a request for the data in
question. @var{data} can be any void*. @var{data} is meaningless if
the @var{want} is false.
@end deftypefn

@deftypefn {Virtual} {Reader::Request} Reader::object (const std::string& @var{name}, const std::string& @var{protocol}, unsigned int @var{protocolVersion}, const ObjectInfo& @var{header})
This function is called whenever the Reader base class encounters an
ObjectHeader. The derived class should override this function and
return a Request object to indicate whether data should be read for
the object in question. If it requests not to have data read, the
Reader will not call the corresponding component() and property()
functions.
@end deftypefn

@deftypefn {Virtual} {Reader::Request} Reader::component (const std::string& @var{name}, const ComponentInfo& @var{header})
This function is called when the Reader base class encounters a
ComponentHeader in the GTO file. If the derived class did not express
interest in a particular object in the file by returning
@code{Request(false)} from the object() function, the components of
that object will not be presented to the derived class. The derived
class should return @code{Request(true)} to indicate that it is interested in the
properties of this @var{component}.
@end deftypefn

@deftypefn {Virtual} {Reader::Request} Reader::property (const std::string& @var{name}, const PropertyInfo& @var{header})
This function is called when the Reader base class encounters a
PropertyHeader in the GTO file. If the derived class did not express
interest in a particular object or the component that the property
belongs to, the properties of that component will not be presented to
the derived class. The derived class should return
@code{Request(true)} to indicate it is interested in the property
data.
@end deftypefn

@deftypefn {Virtual} {void*} Reader::data (const PropertyInfo&, size_t @var{byts})
This function is called before property data is read from the GTO
file. The function should return a pointer to memory of at least size
@var{bytes} into which the data will be read. The type, size, width,
etc, of the data can be obtained from the @code{PropertyInfo} structure.
@end deftypefn

@deftypefn {Virtual} {void} Reader::dataRead (const PropertyInfo&)
This function is called after the @code{data()} function if the data
was successfully read. 
@end deftypefn

If you are using the Reader class in @code{Reader::RandomAccess} mode,
you may call these functions after the read function has returned:

@deftypefn {Method} {Reader::Objects&} Reader::objects ()
Returns a reference to an std::vector of Reader::ObjectInfo
structures. These are only valid after @code{Reader::open()} has
returned. You can use these structures when calling
@code{Reader::accessObject()}. 
@end deftypefn

@deftypefn {Method} {const Reader::Components&} Reader::components ()
Returns a reference to an std::vector of Reader::ComponentInfo
structures. These are only valid after @code{Reader::open()} has
returned. This method is most useful when deciding how to call the
@code{accessObject} function.
@end deftypefn

@deftypefn {Method} {const Reader::Properties&} Reader::properties ()
Returns a reference to an std::vector of Reader::PropertyInfo
structures. These are only valid after @code{Reader::open()} has
returned. This method is most useful when deciding how to call the
@code{accessObject} function.
@end deftypefn

@deftypefn {Method} {void} Reader::accessObject (const ObjectInfo&)
Calling this function on a GTO file openned for @code{RandomAccess}
reading will cause the reader to seek into the file just for the data
related to the object passed in. This is most useful when the objects'
data cannot be held in memory and the order of retrieval is
unknown. The reader attempts to be efficient as possible without using
too much memory.
@end deftypefn

@c -------------------------------------------------------------------------
@node Writer, RawData, Reader, Library
@section Gto::Writer class

The Writer class (in namespace Gto) is designed as an API to a state
machine. You indicate a conceptual hierarchy to the file and then all
the data. The writer handles generating the string table, the header
information, etc.

The following is an example that outputs a polygon cube using the
@strong{polygon} protocol.

@example

    float points[3][] = 
    @{   @{ -2.5, 2.5, 2.5 @},  @{ -2.5, -2.5, 2.5 @}, 
        @{ 2.5, -2.5, 2.5 @},  @{ 2.5, 2.5, 2.5 @}, 
        @{ -2.5, 2.5, -2.5 @}, @{ -2.5, -2.5, -2.5 @}, 
        @{ 2.5, -2.5, -2.5 @}, @{ 2.5, 2.5, -2.5 @} @};

    unsigned char type[] = @{ 2, 2, 2, 2, 2, 2 @};
    unsigned char size[] = @{ 4, 4, 4, 4, 4, 4 @};

    int indices[] = @{0, 1, 2, 3,    7, 6, 5, 4, 
                     3, 2, 6, 7,    4, 0, 3, 7, 
                     4, 5, 1, 0,    1, 5, 6, 2 @};

    Gto::Writer writer;
    writer.open("cube.gto");

    writer.beginObject("cube", "polygon", 2);   // polygon version 2

        writer.beginComponent("points");
            // will write 8 float[3] positions
            writer.property("positions", Gto::Float, 8, 3);
        writer.endComponent();

        writer.beginComponent("elements");
            // one per face
            writer.property("size", Gto::Short, 8, 1, 1);
            writer.property("type", Gto::Byte, 8, 1, 1);
        writer.endComponent();

        writer.beginComponent("indices");
            // one per vertex per face
            writer.property("vertex", Gto::Int, 24, 1, 1);
        writer.endComponent();

    writer.endObject();

    // repeat writer object blocks if more objects

    // output all the data in order declared

    writer.beginData();
    writer.propertyData(points);
    writer.propertyData(type);
    writer.propertyData(size);
    writer.propertyData(indices);
    writer.endData();

@end example

@deftypefn {Constructor} {} Writer::Writer ()
Creates a new Writer class object. Typically you'll make one of these
on the stack. This constructor requires you call the open function to
actually start writing the file.
@end deftypefn

@deftypefn {Constructor} {} Writer::Writer (std::ostream&)
Creates a new Writer class object which will output to the passed C++
output stream.
@end deftypefn

@deftypefn {Destructor} {} Writer::~Writer ()
Closes file opened with the open() function if still open. The
destructor will not close any passed in output stream.
@end deftypefn

@deftypefn {Method} bool Writer::open (const char* @var{filename}, bool @var{compress} = true)
Open the file. The Writer will attempt to open file @var{filename}.
If the file is not writable for whatever reason, the function will
return false. If @var{compress} is true (the default value), the
Writer class will output a compressed file. The file can be
uncompressed manually using @command{gzip}. Compression is available
only if the library is compiled with zlib support.
@end deftypefn

@deftypefn {Method} void Writer::close ()
Close the file and clean up temporary data. If the stream constructor
was used, the stream is @emph{not} closed.
@end deftypefn

@deftypefn {Method} {void} Writer::beginObject (const char* @var{name}, const char* @var{protocol}, unsigned int @var{version}) const
Declares an object. Its components and properties must be declared
before endObject() is called. The @var{name} is the name of the object
as it will appear in the gto file. The @var{protocol} is the protocol
string indicating how the object data will be interpreted and the
@var{version} number indicates the protocol version. The Writer class
does not verify that the data output conforms to the protocol.
@end deftypefn

@deftypefn {Method} {void} Writer::beginComponent (const char* @var{name}, bool @var{transposed}=false) 
Declares a component. The component properties must be declared before
a call to endComponent(). The @var{name} is the name of the component
as it will appear in the gto file. The @var{transposed} flag is
optional and indicates whether or not the component property data
should be output transposed or one property at a time (the default).
@end deftypefn

@deftypefn {Method} {void} Writer::property (const char* @var{name}, Gto::DataType @var{type}, size_t @var{numElements}, size_t @var{partsPerElement}=1)
Declare a property. The @var{name} is the name of the property as it
appears in the gto file. The @var{type} is one of Gto::Double,
Gto::Float, Gto::Int, Gto::String, Gto::Byte, Gto::Half, or
Gto::Short. @var{numElements} indicates the number of elements of size
@var{partsPerElement} that will be in the property data. So for
example, if the property is declared as a Gto::Float of
with @var{partsPerElement} of 3 and there 10 of them, then the writer
will expect an array of 30 floats when the propertyData is finally
passed to it.
@end deftypefn

@deftypefn {Method} {void} Writer::endComponent ()
Closes the declaration of a component started by beginComponent().
@end deftypefn

@deftypefn {Method} {void} Writer::endObject ()
Closes the declaration of an object started by beginObject().
@end deftypefn

@deftypefn {Method} {void} Writer::intern (const char* @var{string})
Declares a string to the Writer for inclusion in the file string
table. When writing properties of type Gto::String, its necessary to
call this function before the beginData() is called. Each string in
the property data must be interned. When outputing the property, the
property will be an array of Gto::Int in which each int is the result
of the lookup() function which retrieves a unique int corresponding to
interned strings. 
@end deftypefn

@deftypefn {Method} {void} Writer::intern (const std::string& @var{string})
Same as above, but takes an std::string.
@end deftypefn

@deftypefn {Method} {int} Writer::lookup (const char* @var{string})
Retrieve the identifier of the previously interned string
@var{string}. 
@end deftypefn

@deftypefn {Method} {int} Writer::lookup (const std::string& @var{string})
Same as above, but takes an std::string&.
@end deftypefn

@deftypefn {Method} {void} Writer::beginData ()
Begins data declaration to the Writer class. Only calls to lookup(),
propertyData(), propertyDataInContainer(), and endData() are legal
after beginData() is called.
@end deftypefn

@deftypefn {Method} {void} Writer::propertyData (const TYPE* @var{type})
propertyData() is a template function which takes a pointer to
continuously stored data. The data must be the same as declared
earlier by the property() function. Calls to propertyData() and
propertyDataInContainer() must appear in the same order as the
property() declarations calls.
@end deftypefn

@deftypefn {Method} {void} Writer::propertyDataInContainer (const TYPE& @var{container})
propertyDataInContainer() is a template function which takes an
stl-like container as an argument. The data must be the same as
declared earlier by the property() function. Calls to propertyData()
and propertyDataInContainer() must appear in the same order as the
property() declarations calls. This function is a convenience
function; it calls propertyData() to actually output the data. This
function may make a copy of the data in the container.
@end deftypefn

@deftypefn {Method} {void} Writer::endData ()
Closes the definition of data started by beginData() and finishes
writing the gto file.
@end deftypefn

@deftypefn {Method} {const Writer::Properties&} Writer::properties () const
Returns a vector of previously declared properties; these are the
result of calls to the property() function.
@end deftypefn

@c -------------------------------------------------------------------------
@node RawData,  , Writer, Library
@section Gto::RawDataReader/Gto::RawDataWriter classes

These classes provide a quick method of reading the contents of a GTO
file into memory for basic editing. The RawDataReader and
RawDataWriter both use the same very primitive data structure that can
be found in the RawData.h file. For examples of use, see
@command{gtomerge} and @command{gtofilter} source code.

The RawData class shows how to both read and write using the supplied
classes. In addition the reader subclass shows how to convert string
data. 

@c -------------------------------------------------------------------------
@c -------------------------------------------------------------------------
@node Module, Utilities, Library, Top
@chapter Python Module

The @code{gto} module implements a reader/writer library for the Python
language. The module is implemented on top of the C++ reader and writer
classes. The API is similar to the C++ API, but takes advantage of Python's
dynamic typing to ``simplify'' the design.  The Python module also implements a
significant number of safety checks not present in the C++ library, making it
an ideal way of exploring the Gto file format.

@menu
* PyReader::      Read GTO files
* PyWriter::      Write GTO files
* PyStructs::     Classes used by gto.Reader
@end menu

@c -------------------------------------------------------------------------
@node PyReader, PyWriter, Module, Module
@section gto.Reader

The Reader class is designed as a fill-in-the-blank API much like the
C++ library. The user of the class derives from it; the base class
defines a number of functions which you override to pass data to the
derived class and receive data from it.

As the file is read, the Reader class will call specific functions in
itself to declare objects in the file. The derived class is handed
data or asked to return whether or not it is interested in specific
properties in the file.

The biggest difference from the C++ Reader class is that the data() method of
the C++ class, which returns allocated memory for the library to read data
into, cannot be overloaded in Python.  Instead, the dataRead() method of the
Python gto.Reader class is handed pre-allocated Python objects containing the
data.

@deftypefn {Constructor} {@var{status}} gto.Reader (@var{mode})
Create a new gto.Reader instance.  Possible values for @var{mode}:

@table @strong
@item gto.Reader.None
The reader will be used in its standard @emph{streaming} mode. The
reader will attempt to read all the data in the file. This is the
default value (or 0).

@item gto.Reader.HeaderOnly   (@emph{Not yet available})
The reader will stop once it has read the header sections of the GTO file. 

@item gto.Reader.RandomAccess   (@emph{Not yet available})
The reader will read the header sections but not the data, however, it
will initialize for use of the @code{Reader::accessObject()} function.

@end table

@end deftypefn

@deftypefn {Method} gto.Reader.open (@var{filename})
Opens and reads the GTO file @var{filename}. The function will raise a Python
exception if the file cannot be opened.
@end deftypefn

@deftypefn {Method} {@var{wants}} gto.Reader.object (@var{name}, @var{protocol}, @var{protocolVersion}, @var{objectInfo})
This function is called by the base class to declare an object in the GTO file.
The return value @var{wants} should evaluate to True or False, indicating
whether or not the base class should read the object data. @var{name} and
@var{protocol} are strings declaring name and protocol of the object,
@var{protocolVersion} is an integer. @var{objectInfo} is an instance of a 
generic class which mimicks the behavior of the ObjectInfo C++ struct.
@end deftypefn

@deftypefn {Method} {@var{wants}} gto.Reader.component (@var{name}, @var{componentInfo})
This function is called by the base class to declare a component in the GTO
file. The return value @var{wants} should evaluate to True or False, indicating
whether or not the base class should read the component data.  @var{name} is a
string declaring the component name. @var{componentInfo} is an instance of
a generic class which mimicks the behavior of the ComponentInfo C++ struct.
@end deftypefn

@deftypefn {Method} {@var{wants}} gto.Reader.property (@var{name}, @var{propertyInfo})
This function is called by the base class to declare a property in the GTO
file. The return value @var{wants} should evaluate to True or False, indicating
whether or not the base class should read the property data.  @var{name} is a
string declaring the full property name. @var{propertyInfo} is an instance of a
generic class which mimicks the behavior of the PropertyInfo C++ struct.
@end deftypefn

@deftypefn {Method} {} gto.Reader.dataRead (@var{name}, @var{data}, @var{propertyInfo})
If a property has been requested, the dataRead() function will eventually be
called by the base class with the actual data in the file. The @var{name} is
the name of property, @var{data} is a tuple containing the property data,
@var{propertyInfo} is an instance of a generic class which mimicks the behavior
of the PropertyInfo C++ struct.
@end deftypefn


@c -------------------------------------------------------------------------
@node PyWriter, PyStructs, PyReader, Module
@section gto.Writer

@deftypefn {Constructor} {} gto.Writer ( )
Creates a new writer instance, no arguments needed.
@end deftypefn

@deftypefn {Method} {} gto.Writer.open (@var{filename})
Open the file. The Writer will attempt to open file 
@var{filename}.  If the file is not writable for whatever reason, the
function will raise a Python exception.
@end deftypefn

@deftypefn {Method} {} gto.Writer.close ( )
Close the file and clean up temporary data.  Because of Python's
garbage-collection, you can never be sure when a class's destructor will be
called.  Therefore, it is @emph{highly} recommended that you call this method to
close your file when it's done writing.  You have been warned.
@end deftypefn

@deftypefn {Method} {} gto.Writer.beginObject (@var{name}, @var{protocol}, @var{version}) 
Declares an object. Its components and properties must be declared
before endObject() is called. The @var{name} is the name of the object
as it will appear in the gto file. The @var{protocol} is the protocol
string indicating how the object data will be interpreted and the
@var{version} number indicates the protocol version. The Writer class
does not verify that the data output conforms to the protocol.
@end deftypefn

@deftypefn {Method} {} gto.Writer.beginComponent (@var{name}, @var{transposed}) 
Declares a component. The component properties must be declared before
a call to endComponent(). The @var{name} is the name of the component
as it will appear in the gto file. The @var{transposed} flag is
optional and indicates whether or not the component property data
should be output transposed or one property at a time (the default).
@end deftypefn

@deftypefn {Method} {} gto.Writer.property (@var{name}, @var{type}, @var{numElements}, @var{partsPerElement})
Declare a property. The @var{name} is the name of the property as it
appears in the gto file. The @var{type} is one of gto.Double,
gto.Float, gto.Int, gto.String, gto.Byte, gto.Half, or
gto.Short. @var{numElements} indicates the number of elements of size
@var{partsPerElement} that will be in the property data. So for
example, if the property is declared as a gto.Float of
with @var{partsPerElement} of 3 and there 10 of them, then the writer
will expect a sequence of 30 floats when the propertyData is finally
passed to it.
@end deftypefn

@deftypefn {Method} {} gto.Writer.endComponent ()
Closes the declaration of a component started by beginComponent().
@end deftypefn

@deftypefn {Method} {} gto.Writer.endObject ()
Closes the declaration of an object started by beginObject().
@end deftypefn

@deftypefn {Method} {} gto.Writer.intern (@var{string})
Declares a string to the Writer for inclusion in the file string table. When
writing properties of type gto.String, its necessary to call this function for
each string in the property data before the beginData() is called.  The Python
version of intern() can accept individual strings, as well as lists or tuples
of strings.
@end deftypefn

@deftypefn {Method} {int} gto.Writer.lookup (@var{string})
Retrieve the identifier of the previously interned string.  Valid only after
beginData() has been called.
@end deftypefn

@deftypefn {Method} {} gto.Writer.beginData ()
Begins data declaration to the Writer class. Only calls to lookup(),
propertyData(), and endData() are legal after beginData() is called.
@end deftypefn

@deftypefn {Method} {} gto.Writer.propertyData (@var{data})

The propertyData() function must get exactly @emph{one} parameter.  That
parameter can be any of the following:

@itemize 
@item
A single int, float, string, etc.
@item
An instance of mat3, vec3, mat4, vec4, or quat
(@url{http://cgkit.sourceforge.net/}).  DO NOT explicitly cast mat3 or mat4 into a
tuple or list: @code{tuple(mat4(1))}.  It will be silently transposed (a bug in the
cgtypes code?).  ADDING it to a tuple or list is fine:  @code{(mat4(1),)}
@item
A tuple or list of any combination of the above that makes sense.
@end itemize

Tuples and lists are flattened out before they are written.  As long as the
number of atoms is equal to size x width, it'll work.  Calls to propertyData()
must appear in the same order as declared with the property() method.

@end deftypefn

@deftypefn {Method} {void} gto.Writer.endData ()
Closes the definition of data started by beginData() and finishes
writing the gto file.  Does @emph{not} actually close the file--use the close()
method for that.
@end deftypefn

@c -------------------------------------------------------------------------
@node PyStructs,  , PyWriter, Module
@section Classes used by gto.Reader


@deftp {Class} gto.ObjectInfo
This class emulates the Gto::ObjectInfo struct from the C++ Gto library.  It is
passed by the Python gto.Reader class to your derived @code{object()} method. 
The only method implemented is @code{__getattr__}.  Available attributes are:

@itemize
@item @code{name} - Integer string table ID
@item @code{protocol} - Integer string table ID
@item @code{protocolVersion}  - Integer 
@item @code{numComponents} - Integer
@end itemize

@end deftp

@deftp {Class} gto.ComponentInfo
This class emulates the Gto::ComponentInfo struct from the C++ Gto library.  It
is passed by the Python gto.Reader class to your derived @code{component()}
method.  The only method implemented is @code{__getattr__}.  Available
attributes are:

@itemize
@item @code{name} - Integer string table ID    
@item @code{numProperties} - Integer
@item @code{flags} - Integer
@item @code{object} - Instance of gto.ObjectInfo
@end itemize

@end deftp

@deftp {Class} gto.PropertyInfo
This class emulates the Gto::PropertyInfo struct from the C++ Gto library.  It
is passed by the Python gto.Reader class to your derived @code{property()} and
@code{dataRead()} methods.  The only method implemented is @code{__getattr__}. 
Available attributes are:

@itemize
@item @code{name} - Integer string table ID
@item @code{size} - Integer
@item @code{type} - Integer
@item @code{width} - Integer
@item @code{component} - Instance of gto.ComponentInfo
@end itemize

@end deftp

@c -------------------------------------------------------------------------
@c -------------------------------------------------------------------------

@node Utilities, Changes, Module, Top
@chapter Utilities

@menu
Command line tools

* gtoinfo::      Find out what's in the gto file.
* gtofilter::    Filter properties out of a gto file.
* gtomerge::     Merge the contents of multiple gto files into one.
* gto2obj::      Wavefront .obj translator.
* gtoimage::     Make an image into a GTO object.

Maya plug-in.

* gtoIO::        Maya likes gto files.
@end menu

@c -------------------------------------------------------------------------

@node gtoinfo, gtofilter, Utilities, Utilities
@section The @command{gtoinfo} Utility

Usage: @command{gtoinfo [OPTIONS] @var{infile.gto}}

Options:

@table @option
@item -a/-all
Output property data and header.

@item -d/--dump
Output property data (no header data is emitted).

@item -l/--line
Output property data one item per line. Can be used with either
@option{-d} or @option{-s}.

@item -h/--header
Output header data.

@item -s/--strings
Output sting table data.

@item -n/--numeric-strings
Output sting data as the raw string id instead of the string itself.

@item -r/--readall
Force reading of the enitre gto file even if only the header is being
output.

@item -f/--filter expression
Only output information for properties who's long name
(object.component.propname) matches the shell-like
@emph{expression}. @ref{gtofilter} for examples of filter
expressions. This option is similar to @command{gtofilter}
@option{--include} option.

@item --help
Output usage message.

@end table

@command{gtoinfo} outputs the part of all of the contents of a gto
file in human readable form. Its invaluable for debugging or just
getting a quick understanding of what a gto file contains.


@c -------------------------------------------------------------------------

@node gtofilter, gtomerge, gtoinfo, Utilities
@section The @command{gtofilter} Utility

Usage: @samp{gtofilter [OPTIONS] -o @var{out.gto} @var{in.gto}}

Options:

@table @option

@item -v
Set verbose output. Whenever a pattern matches gtofilter will inform
you.

@item -ee/--exclude
Regular expression which will be used to exclude properties.

@item -ie/--include
Regular expression which will be used to include properties.

@item -regex
Use POSIX regular expression syntax.

@item -glob
Use shell-like regular expression (fnmatch). This is the default.

@item -o @var{out.gto}
output .gto file

@end table

@command{gtofilter} can be used to remove objects, components, and
properties from a gto file. You supply an include shell-like
expression and/or an exclude shell-like expression. (The pattern
matching is done using the fnmatch() function -- see the man page for
details.) 

The patterns match each full property name. So for example a cube
might have these properties:

@example 
    cube.points.position 
    cube.elements.type 
    cube.elements.size
    cube.indices.vertex 
    cube.indices.st
    cube.indices.normal
    cube.normals.normal
    cube.mappings.st
    cube.smoothing.method
    cube.object.globalMatrix
    cube.object.parent
@end example

Using the @option{--exclude} option, you can remove the object
component by doing this:

@example
    gtofilter --exclude "*.object.*" -o out.gto cube.gto
@end example

or if you wanted to pass through only the positions:

@example
    gtofilter --include "*.*.positions" -o out.gto cube.gto

        -or-

    gtofilter --include "*positions" -o out.gto cube.gto
@end example

@c -------------------------------------------------------------------------

@node gtomerge, gto2obj, gtofilter, Utilities
@section The @command{gtomerge} Utility

Usage: @samp{gtomerge -o @var{outfile.gto} @var{infile1.gto} @var{infile2.gto} ...}

Options:

@table @option
@item -o outfile.gto
The resulting merged file to output.
@end table

@command{gtomerge} takes a number of .gto input files and merges them
into a single output .gto file. This is done by first creating output
geometry that is identical to the first input file and then adding
only those properties that are not already defined from subsequent gto
files. The order of input files determines what will be in the final
output file.

For @strong{difference} files, you can use gtomerge to reconstruct a
final file like this:

@example
    gtomerge -o out.gto difference.gto reference.gto
@end example

@c -------------------------------------------------------------------------

@node gto2obj, gtoimage, gtomerge, Utilities
@section The @command{gto2obj} Utility

Usage: @samp{gto2obj [OPTIONS] @var{infile} @var{outfile}}

Options:

@table @option
@item -o NAME
When outputing GTO files, the name of an object in the GTO file to
output. If not specified, the translator will output the first
polygon, or subdivision surface it finds.

@item -c
When outputing GTO files, this option will force the protocol to be
"catmull-clark".

@item -l
When outputing GTO files, this option will force the protocol to be
"loop".
@end table

@command{gto2obj} takes either an input GTO file or Wavefront .obj
file and outputs the other file type.

@example
    gto2obj in.obj out.gto
    gto2obj in.gto out.obj
    gto2obj -c in.obj out.gto ## output obj as subdivision surface
@end example

@c -------------------------------------------------------------------------

@node gtoimage, gtoIO, gto2obj, Utilities
@section The @command{gtoimage} Utility

Usage: @samp{gtoimage @var{infile} @var{outfile}}

@command{gtoimage} reads a TIFF file and converts it into a GTO file
containing one image object. 32 bit floating point images, 16 bit and
8 bit integral images are directly converted. @command{gtoimage}
expects the image to be two dimensional with three or four channels
where the fourth channel is an optional alpha value. The output object
conforms to the @strong{image} protocol. @xref{Image}.

You can use @command{gtomerge} to merge the image object into another
GTO file. @xref{gtomerge}.

It is highly recommend that the resulting output GTO file be written
with compression or gzipped to reduce its size. Gzipped GTO files can
be read directly by the supplied readers.


@c -------------------------------------------------------------------------

@node gtoIO,  , gtoimage, Utilities
@section The @command{gtoIO.so} Maya Plug-In

The Maya plugin comes in two parts: the C++ plugin which implements a
Maya scene translator and an accompanying MEL script which implements
the user interface.

The plugin handles export of NURBS surfaces (but not trim curves),
polygonal geometry (which can be written as sub-division surfaces),
particles, and generic transforms. Additional user defined attributes
can be emitted into the GTO file.

The plugin can import everything that it exports.

@subsection BUGS

The internal perfomance of Maya has changed between the 4.x and 5.0
versions. In Maya 5.0, the Maya plugin is @emph{extremely} slow when
importing polygonal normals. A fix has yet to be identified.

@c -------------------------------------------------------------------------

@node Changes, Reference, Utilities, Top
@appendix Description of Changes


@itemize @bullet
@item Version 2.1

@itemize @bullet

@item
@command{gtofilter} was changed to optionaly accept POSIX style
regular expressions in addition to shell-like ``glob'' expressions.

@item 
The C++ writer class now defaults to writing compressed files when the
open() function is called. A second bool argument can be passed to it
to prevent the compression.

@item 
The proposed texture assignment protocol (from version 2.0.4) has been
rejected.

@item
A new protocol ``channel'' is introduced for assigning mapped surface
varying data on geometry. An arbitrary number of texture maps may be
assigned to the geometry. @xref{Channels}.

@item
The material protocol has been fleshed out. @xref{Material}.

@item
The polygon protocol was missing the definition of the optional
@strong{mappings} component. @xref{Polygonal Surfaces}.

@end itemize


@item Version 2.0.5
Bug fix version. Repaired problems with the configuration
scripts. Missing headers.

@item Version 2.0.4
Bug fix version. Some configuration problems solved.

@item Version 2.0
File headers changed. The format is not compatible with 1.0.

@item Version 1.0
@end itemize


@c -------------------------------------------------------------------------

@node Reference,  , Changes, Top
@appendix Reference

@heading Properties
@printindex vr

@heading Functions
@printindex fn

@bye
